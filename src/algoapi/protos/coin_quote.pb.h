// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/coin_quote.proto

#ifndef PROTOBUF_INCLUDED_protos_2fcoin_5fquote_2eproto
#define PROTOBUF_INCLUDED_protos_2fcoin_5fquote_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_protos_2fcoin_5fquote_2eproto 

namespace protobuf_protos_2fcoin_5fquote_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[25];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_protos_2fcoin_5fquote_2eproto
namespace digitalcurrency {
class AskBid;
class AskBidDefaultTypeInternal;
extern AskBidDefaultTypeInternal _AskBid_default_instance_;
class DIterm;
class DItermDefaultTypeInternal;
extern DItermDefaultTypeInternal _DIterm_default_instance_;
class DepthData;
class DepthDataDefaultTypeInternal;
extern DepthDataDefaultTypeInternal _DepthData_default_instance_;
class DepthItem;
class DepthItemDefaultTypeInternal;
extern DepthItemDefaultTypeInternal _DepthItem_default_instance_;
class KlineData;
class KlineDataDefaultTypeInternal;
extern KlineDataDefaultTypeInternal _KlineData_default_instance_;
class OrderData;
class OrderDataDefaultTypeInternal;
extern OrderDataDefaultTypeInternal _OrderData_default_instance_;
class PriceData;
class PriceDataDefaultTypeInternal;
extern PriceDataDefaultTypeInternal _PriceData_default_instance_;
class ReqCancelTrade;
class ReqCancelTradeDefaultTypeInternal;
extern ReqCancelTradeDefaultTypeInternal _ReqCancelTrade_default_instance_;
class ReqDepth;
class ReqDepthDefaultTypeInternal;
extern ReqDepthDefaultTypeInternal _ReqDepth_default_instance_;
class ReqKline;
class ReqKlineDefaultTypeInternal;
extern ReqKlineDefaultTypeInternal _ReqKline_default_instance_;
class ReqNewTrade;
class ReqNewTradeDefaultTypeInternal;
extern ReqNewTradeDefaultTypeInternal _ReqNewTrade_default_instance_;
class ReqOrderInfo;
class ReqOrderInfoDefaultTypeInternal;
extern ReqOrderInfoDefaultTypeInternal _ReqOrderInfo_default_instance_;
class ReqPrice;
class ReqPriceDefaultTypeInternal;
extern ReqPriceDefaultTypeInternal _ReqPrice_default_instance_;
class ReqTradeList;
class ReqTradeListDefaultTypeInternal;
extern ReqTradeListDefaultTypeInternal _ReqTradeList_default_instance_;
class RespCancelTrade;
class RespCancelTradeDefaultTypeInternal;
extern RespCancelTradeDefaultTypeInternal _RespCancelTrade_default_instance_;
class RespDepth;
class RespDepthDefaultTypeInternal;
extern RespDepthDefaultTypeInternal _RespDepth_default_instance_;
class RespKline;
class RespKlineDefaultTypeInternal;
extern RespKlineDefaultTypeInternal _RespKline_default_instance_;
class RespNewTrade;
class RespNewTradeDefaultTypeInternal;
extern RespNewTradeDefaultTypeInternal _RespNewTrade_default_instance_;
class RespOrderInfo;
class RespOrderInfoDefaultTypeInternal;
extern RespOrderInfoDefaultTypeInternal _RespOrderInfo_default_instance_;
class RespPrice;
class RespPriceDefaultTypeInternal;
extern RespPriceDefaultTypeInternal _RespPrice_default_instance_;
class RespTradeList;
class RespTradeListDefaultTypeInternal;
extern RespTradeListDefaultTypeInternal _RespTradeList_default_instance_;
class TIterm;
class TItermDefaultTypeInternal;
extern TItermDefaultTypeInternal _TIterm_default_instance_;
class TickerData;
class TickerDataDefaultTypeInternal;
extern TickerDataDefaultTypeInternal _TickerData_default_instance_;
class TickerItem;
class TickerItemDefaultTypeInternal;
extern TickerItemDefaultTypeInternal _TickerItem_default_instance_;
class TradeData;
class TradeDataDefaultTypeInternal;
extern TradeDataDefaultTypeInternal _TradeData_default_instance_;
}  // namespace digitalcurrency
namespace google {
namespace protobuf {
template<> ::digitalcurrency::AskBid* Arena::CreateMaybeMessage<::digitalcurrency::AskBid>(Arena*);
template<> ::digitalcurrency::DIterm* Arena::CreateMaybeMessage<::digitalcurrency::DIterm>(Arena*);
template<> ::digitalcurrency::DepthData* Arena::CreateMaybeMessage<::digitalcurrency::DepthData>(Arena*);
template<> ::digitalcurrency::DepthItem* Arena::CreateMaybeMessage<::digitalcurrency::DepthItem>(Arena*);
template<> ::digitalcurrency::KlineData* Arena::CreateMaybeMessage<::digitalcurrency::KlineData>(Arena*);
template<> ::digitalcurrency::OrderData* Arena::CreateMaybeMessage<::digitalcurrency::OrderData>(Arena*);
template<> ::digitalcurrency::PriceData* Arena::CreateMaybeMessage<::digitalcurrency::PriceData>(Arena*);
template<> ::digitalcurrency::ReqCancelTrade* Arena::CreateMaybeMessage<::digitalcurrency::ReqCancelTrade>(Arena*);
template<> ::digitalcurrency::ReqDepth* Arena::CreateMaybeMessage<::digitalcurrency::ReqDepth>(Arena*);
template<> ::digitalcurrency::ReqKline* Arena::CreateMaybeMessage<::digitalcurrency::ReqKline>(Arena*);
template<> ::digitalcurrency::ReqNewTrade* Arena::CreateMaybeMessage<::digitalcurrency::ReqNewTrade>(Arena*);
template<> ::digitalcurrency::ReqOrderInfo* Arena::CreateMaybeMessage<::digitalcurrency::ReqOrderInfo>(Arena*);
template<> ::digitalcurrency::ReqPrice* Arena::CreateMaybeMessage<::digitalcurrency::ReqPrice>(Arena*);
template<> ::digitalcurrency::ReqTradeList* Arena::CreateMaybeMessage<::digitalcurrency::ReqTradeList>(Arena*);
template<> ::digitalcurrency::RespCancelTrade* Arena::CreateMaybeMessage<::digitalcurrency::RespCancelTrade>(Arena*);
template<> ::digitalcurrency::RespDepth* Arena::CreateMaybeMessage<::digitalcurrency::RespDepth>(Arena*);
template<> ::digitalcurrency::RespKline* Arena::CreateMaybeMessage<::digitalcurrency::RespKline>(Arena*);
template<> ::digitalcurrency::RespNewTrade* Arena::CreateMaybeMessage<::digitalcurrency::RespNewTrade>(Arena*);
template<> ::digitalcurrency::RespOrderInfo* Arena::CreateMaybeMessage<::digitalcurrency::RespOrderInfo>(Arena*);
template<> ::digitalcurrency::RespPrice* Arena::CreateMaybeMessage<::digitalcurrency::RespPrice>(Arena*);
template<> ::digitalcurrency::RespTradeList* Arena::CreateMaybeMessage<::digitalcurrency::RespTradeList>(Arena*);
template<> ::digitalcurrency::TIterm* Arena::CreateMaybeMessage<::digitalcurrency::TIterm>(Arena*);
template<> ::digitalcurrency::TickerData* Arena::CreateMaybeMessage<::digitalcurrency::TickerData>(Arena*);
template<> ::digitalcurrency::TickerItem* Arena::CreateMaybeMessage<::digitalcurrency::TickerItem>(Arena*);
template<> ::digitalcurrency::TradeData* Arena::CreateMaybeMessage<::digitalcurrency::TradeData>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace digitalcurrency {

enum MessgeTypeID {
  ReqDepthID = 1,
  RespDetphID = 2
};
bool MessgeTypeID_IsValid(int value);
const MessgeTypeID MessgeTypeID_MIN = ReqDepthID;
const MessgeTypeID MessgeTypeID_MAX = RespDetphID;
const int MessgeTypeID_ARRAYSIZE = MessgeTypeID_MAX + 1;

const ::google::protobuf::EnumDescriptor* MessgeTypeID_descriptor();
inline const ::std::string& MessgeTypeID_Name(MessgeTypeID value) {
  return ::google::protobuf::internal::NameOfEnum(
    MessgeTypeID_descriptor(), value);
}
inline bool MessgeTypeID_Parse(
    const ::std::string& name, MessgeTypeID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MessgeTypeID>(
    MessgeTypeID_descriptor(), name, value);
}
enum TradingPair {
  BTCUSDT = 0,
  ETHUSDT = 1,
  BCHUSDT = 2
};
bool TradingPair_IsValid(int value);
const TradingPair TradingPair_MIN = BTCUSDT;
const TradingPair TradingPair_MAX = BCHUSDT;
const int TradingPair_ARRAYSIZE = TradingPair_MAX + 1;

const ::google::protobuf::EnumDescriptor* TradingPair_descriptor();
inline const ::std::string& TradingPair_Name(TradingPair value) {
  return ::google::protobuf::internal::NameOfEnum(
    TradingPair_descriptor(), value);
}
inline bool TradingPair_Parse(
    const ::std::string& name, TradingPair* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TradingPair>(
    TradingPair_descriptor(), name, value);
}
enum Exchange {
  Exchange_OKCOIN = 0,
  Exchange_BINANCE = 1,
  Exchange_HUOBI = 2
};
bool Exchange_IsValid(int value);
const Exchange Exchange_MIN = Exchange_OKCOIN;
const Exchange Exchange_MAX = Exchange_HUOBI;
const int Exchange_ARRAYSIZE = Exchange_MAX + 1;

const ::google::protobuf::EnumDescriptor* Exchange_descriptor();
inline const ::std::string& Exchange_Name(Exchange value) {
  return ::google::protobuf::internal::NameOfEnum(
    Exchange_descriptor(), value);
}
inline bool Exchange_Parse(
    const ::std::string& name, Exchange* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Exchange>(
    Exchange_descriptor(), name, value);
}
enum KlineInterval {
  OneMinute = 1,
  ThreeMinute = 2,
  FiveMinute = 3,
  FifteenMinute = 4,
  ThirtyMinute = 5,
  OneHour = 6,
  TwoHour = 7,
  FourHour = 8,
  SixHour = 9,
  TwelveHour = 10,
  OneDay = 11,
  ThreeDay = 12,
  OneWeek = 13
};
bool KlineInterval_IsValid(int value);
const KlineInterval KlineInterval_MIN = OneMinute;
const KlineInterval KlineInterval_MAX = OneWeek;
const int KlineInterval_ARRAYSIZE = KlineInterval_MAX + 1;

const ::google::protobuf::EnumDescriptor* KlineInterval_descriptor();
inline const ::std::string& KlineInterval_Name(KlineInterval value) {
  return ::google::protobuf::internal::NameOfEnum(
    KlineInterval_descriptor(), value);
}
inline bool KlineInterval_Parse(
    const ::std::string& name, KlineInterval* value) {
  return ::google::protobuf::internal::ParseNamedEnum<KlineInterval>(
    KlineInterval_descriptor(), name, value);
}
enum TradeType {
  BuyMarket = 1,
  SellMarket = 2,
  BuyLimit = 3,
  SellLimit = 4
};
bool TradeType_IsValid(int value);
const TradeType TradeType_MIN = BuyMarket;
const TradeType TradeType_MAX = SellLimit;
const int TradeType_ARRAYSIZE = TradeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TradeType_descriptor();
inline const ::std::string& TradeType_Name(TradeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TradeType_descriptor(), value);
}
inline bool TradeType_Parse(
    const ::std::string& name, TradeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TradeType>(
    TradeType_descriptor(), name, value);
}
enum OrderStatus {
  Canceled = 1,
  NoDeal = 2,
  PartialDeal = 3,
  CompleteDeal = 4,
  Canceling = 5
};
bool OrderStatus_IsValid(int value);
const OrderStatus OrderStatus_MIN = Canceled;
const OrderStatus OrderStatus_MAX = Canceling;
const int OrderStatus_ARRAYSIZE = OrderStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* OrderStatus_descriptor();
inline const ::std::string& OrderStatus_Name(OrderStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    OrderStatus_descriptor(), value);
}
inline bool OrderStatus_Parse(
    const ::std::string& name, OrderStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OrderStatus>(
    OrderStatus_descriptor(), name, value);
}
// ===================================================================

class TIterm : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:digitalcurrency.TIterm) */ {
 public:
  TIterm();
  virtual ~TIterm();

  TIterm(const TIterm& from);

  inline TIterm& operator=(const TIterm& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TIterm(TIterm&& from) noexcept
    : TIterm() {
    *this = ::std::move(from);
  }

  inline TIterm& operator=(TIterm&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TIterm& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TIterm* internal_default_instance() {
    return reinterpret_cast<const TIterm*>(
               &_TIterm_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(TIterm* other);
  friend void swap(TIterm& a, TIterm& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TIterm* New() const final {
    return CreateMaybeMessage<TIterm>(NULL);
  }

  TIterm* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TIterm>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TIterm& from);
  void MergeFrom(const TIterm& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TIterm* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 timestamp = 1;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // optional int64 high = 2;
  bool has_high() const;
  void clear_high();
  static const int kHighFieldNumber = 2;
  ::google::protobuf::int64 high() const;
  void set_high(::google::protobuf::int64 value);

  // optional int64 low = 3;
  bool has_low() const;
  void clear_low();
  static const int kLowFieldNumber = 3;
  ::google::protobuf::int64 low() const;
  void set_low(::google::protobuf::int64 value);

  // optional int64 dayHigh = 4;
  bool has_dayhigh() const;
  void clear_dayhigh();
  static const int kDayHighFieldNumber = 4;
  ::google::protobuf::int64 dayhigh() const;
  void set_dayhigh(::google::protobuf::int64 value);

  // optional int64 dayLow = 5;
  bool has_daylow() const;
  void clear_daylow();
  static const int kDayLowFieldNumber = 5;
  ::google::protobuf::int64 daylow() const;
  void set_daylow(::google::protobuf::int64 value);

  // optional int64 vol = 6;
  bool has_vol() const;
  void clear_vol();
  static const int kVolFieldNumber = 6;
  ::google::protobuf::int64 vol() const;
  void set_vol(::google::protobuf::int64 value);

  // optional int64 last = 7;
  bool has_last() const;
  void clear_last();
  static const int kLastFieldNumber = 7;
  ::google::protobuf::int64 last() const;
  void set_last(::google::protobuf::int64 value);

  // optional int64 buy = 8;
  bool has_buy() const;
  void clear_buy();
  static const int kBuyFieldNumber = 8;
  ::google::protobuf::int64 buy() const;
  void set_buy(::google::protobuf::int64 value);

  // optional int64 sell = 9;
  bool has_sell() const;
  void clear_sell();
  static const int kSellFieldNumber = 9;
  ::google::protobuf::int64 sell() const;
  void set_sell(::google::protobuf::int64 value);

  // optional int64 change = 10;
  bool has_change() const;
  void clear_change();
  static const int kChangeFieldNumber = 10;
  ::google::protobuf::int64 change() const;
  void set_change(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:digitalcurrency.TIterm)
 private:
  void set_has_timestamp();
  void clear_has_timestamp();
  void set_has_high();
  void clear_has_high();
  void set_has_low();
  void clear_has_low();
  void set_has_dayhigh();
  void clear_has_dayhigh();
  void set_has_daylow();
  void clear_has_daylow();
  void set_has_vol();
  void clear_has_vol();
  void set_has_last();
  void clear_has_last();
  void set_has_buy();
  void clear_has_buy();
  void set_has_sell();
  void clear_has_sell();
  void set_has_change();
  void clear_has_change();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int64 timestamp_;
  ::google::protobuf::int64 high_;
  ::google::protobuf::int64 low_;
  ::google::protobuf::int64 dayhigh_;
  ::google::protobuf::int64 daylow_;
  ::google::protobuf::int64 vol_;
  ::google::protobuf::int64 last_;
  ::google::protobuf::int64 buy_;
  ::google::protobuf::int64 sell_;
  ::google::protobuf::int64 change_;
  friend struct ::protobuf_protos_2fcoin_5fquote_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TickerItem : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:digitalcurrency.TickerItem) */ {
 public:
  TickerItem();
  virtual ~TickerItem();

  TickerItem(const TickerItem& from);

  inline TickerItem& operator=(const TickerItem& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TickerItem(TickerItem&& from) noexcept
    : TickerItem() {
    *this = ::std::move(from);
  }

  inline TickerItem& operator=(TickerItem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TickerItem& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TickerItem* internal_default_instance() {
    return reinterpret_cast<const TickerItem*>(
               &_TickerItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(TickerItem* other);
  friend void swap(TickerItem& a, TickerItem& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TickerItem* New() const final {
    return CreateMaybeMessage<TickerItem>(NULL);
  }

  TickerItem* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TickerItem>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TickerItem& from);
  void MergeFrom(const TickerItem& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TickerItem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string channel = 1;
  bool has_channel() const;
  void clear_channel();
  static const int kChannelFieldNumber = 1;
  const ::std::string& channel() const;
  void set_channel(const ::std::string& value);
  #if LANG_CXX11
  void set_channel(::std::string&& value);
  #endif
  void set_channel(const char* value);
  void set_channel(const char* value, size_t size);
  ::std::string* mutable_channel();
  ::std::string* release_channel();
  void set_allocated_channel(::std::string* channel);

  // optional .digitalcurrency.TIterm titerm = 3;
  bool has_titerm() const;
  void clear_titerm();
  static const int kTitermFieldNumber = 3;
  private:
  const ::digitalcurrency::TIterm& _internal_titerm() const;
  public:
  const ::digitalcurrency::TIterm& titerm() const;
  ::digitalcurrency::TIterm* release_titerm();
  ::digitalcurrency::TIterm* mutable_titerm();
  void set_allocated_titerm(::digitalcurrency::TIterm* titerm);

  // optional .digitalcurrency.TradingPair tpair = 2;
  bool has_tpair() const;
  void clear_tpair();
  static const int kTpairFieldNumber = 2;
  ::digitalcurrency::TradingPair tpair() const;
  void set_tpair(::digitalcurrency::TradingPair value);

  // @@protoc_insertion_point(class_scope:digitalcurrency.TickerItem)
 private:
  void set_has_channel();
  void clear_has_channel();
  void set_has_tpair();
  void clear_has_tpair();
  void set_has_titerm();
  void clear_has_titerm();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr channel_;
  ::digitalcurrency::TIterm* titerm_;
  int tpair_;
  friend struct ::protobuf_protos_2fcoin_5fquote_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TickerData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:digitalcurrency.TickerData) */ {
 public:
  TickerData();
  virtual ~TickerData();

  TickerData(const TickerData& from);

  inline TickerData& operator=(const TickerData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TickerData(TickerData&& from) noexcept
    : TickerData() {
    *this = ::std::move(from);
  }

  inline TickerData& operator=(TickerData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TickerData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TickerData* internal_default_instance() {
    return reinterpret_cast<const TickerData*>(
               &_TickerData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(TickerData* other);
  friend void swap(TickerData& a, TickerData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TickerData* New() const final {
    return CreateMaybeMessage<TickerData>(NULL);
  }

  TickerData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TickerData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TickerData& from);
  void MergeFrom(const TickerData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TickerData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .digitalcurrency.TickerItem tickers = 2;
  int tickers_size() const;
  void clear_tickers();
  static const int kTickersFieldNumber = 2;
  ::digitalcurrency::TickerItem* mutable_tickers(int index);
  ::google::protobuf::RepeatedPtrField< ::digitalcurrency::TickerItem >*
      mutable_tickers();
  const ::digitalcurrency::TickerItem& tickers(int index) const;
  ::digitalcurrency::TickerItem* add_tickers();
  const ::google::protobuf::RepeatedPtrField< ::digitalcurrency::TickerItem >&
      tickers() const;

  // optional .digitalcurrency.Exchange exchange = 1;
  bool has_exchange() const;
  void clear_exchange();
  static const int kExchangeFieldNumber = 1;
  ::digitalcurrency::Exchange exchange() const;
  void set_exchange(::digitalcurrency::Exchange value);

  // @@protoc_insertion_point(class_scope:digitalcurrency.TickerData)
 private:
  void set_has_exchange();
  void clear_has_exchange();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::digitalcurrency::TickerItem > tickers_;
  int exchange_;
  friend struct ::protobuf_protos_2fcoin_5fquote_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AskBid : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:digitalcurrency.AskBid) */ {
 public:
  AskBid();
  virtual ~AskBid();

  AskBid(const AskBid& from);

  inline AskBid& operator=(const AskBid& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AskBid(AskBid&& from) noexcept
    : AskBid() {
    *this = ::std::move(from);
  }

  inline AskBid& operator=(AskBid&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AskBid& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AskBid* internal_default_instance() {
    return reinterpret_cast<const AskBid*>(
               &_AskBid_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(AskBid* other);
  friend void swap(AskBid& a, AskBid& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AskBid* New() const final {
    return CreateMaybeMessage<AskBid>(NULL);
  }

  AskBid* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AskBid>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AskBid& from);
  void MergeFrom(const AskBid& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AskBid* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 price = 1;
  bool has_price() const;
  void clear_price();
  static const int kPriceFieldNumber = 1;
  ::google::protobuf::int64 price() const;
  void set_price(::google::protobuf::int64 value);

  // optional int64 amount = 2;
  bool has_amount() const;
  void clear_amount();
  static const int kAmountFieldNumber = 2;
  ::google::protobuf::int64 amount() const;
  void set_amount(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:digitalcurrency.AskBid)
 private:
  void set_has_price();
  void clear_has_price();
  void set_has_amount();
  void clear_has_amount();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int64 price_;
  ::google::protobuf::int64 amount_;
  friend struct ::protobuf_protos_2fcoin_5fquote_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DIterm : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:digitalcurrency.DIterm) */ {
 public:
  DIterm();
  virtual ~DIterm();

  DIterm(const DIterm& from);

  inline DIterm& operator=(const DIterm& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DIterm(DIterm&& from) noexcept
    : DIterm() {
    *this = ::std::move(from);
  }

  inline DIterm& operator=(DIterm&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DIterm& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DIterm* internal_default_instance() {
    return reinterpret_cast<const DIterm*>(
               &_DIterm_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(DIterm* other);
  friend void swap(DIterm& a, DIterm& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DIterm* New() const final {
    return CreateMaybeMessage<DIterm>(NULL);
  }

  DIterm* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DIterm>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DIterm& from);
  void MergeFrom(const DIterm& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DIterm* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .digitalcurrency.AskBid asks = 1;
  int asks_size() const;
  void clear_asks();
  static const int kAsksFieldNumber = 1;
  ::digitalcurrency::AskBid* mutable_asks(int index);
  ::google::protobuf::RepeatedPtrField< ::digitalcurrency::AskBid >*
      mutable_asks();
  const ::digitalcurrency::AskBid& asks(int index) const;
  ::digitalcurrency::AskBid* add_asks();
  const ::google::protobuf::RepeatedPtrField< ::digitalcurrency::AskBid >&
      asks() const;

  // repeated .digitalcurrency.AskBid bids = 2;
  int bids_size() const;
  void clear_bids();
  static const int kBidsFieldNumber = 2;
  ::digitalcurrency::AskBid* mutable_bids(int index);
  ::google::protobuf::RepeatedPtrField< ::digitalcurrency::AskBid >*
      mutable_bids();
  const ::digitalcurrency::AskBid& bids(int index) const;
  ::digitalcurrency::AskBid* add_bids();
  const ::google::protobuf::RepeatedPtrField< ::digitalcurrency::AskBid >&
      bids() const;

  // optional int64 timestamp = 3;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:digitalcurrency.DIterm)
 private:
  void set_has_timestamp();
  void clear_has_timestamp();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::digitalcurrency::AskBid > asks_;
  ::google::protobuf::RepeatedPtrField< ::digitalcurrency::AskBid > bids_;
  ::google::protobuf::int64 timestamp_;
  friend struct ::protobuf_protos_2fcoin_5fquote_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DepthItem : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:digitalcurrency.DepthItem) */ {
 public:
  DepthItem();
  virtual ~DepthItem();

  DepthItem(const DepthItem& from);

  inline DepthItem& operator=(const DepthItem& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DepthItem(DepthItem&& from) noexcept
    : DepthItem() {
    *this = ::std::move(from);
  }

  inline DepthItem& operator=(DepthItem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DepthItem& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DepthItem* internal_default_instance() {
    return reinterpret_cast<const DepthItem*>(
               &_DepthItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(DepthItem* other);
  friend void swap(DepthItem& a, DepthItem& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DepthItem* New() const final {
    return CreateMaybeMessage<DepthItem>(NULL);
  }

  DepthItem* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DepthItem>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DepthItem& from);
  void MergeFrom(const DepthItem& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DepthItem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string channel = 1;
  bool has_channel() const;
  void clear_channel();
  static const int kChannelFieldNumber = 1;
  const ::std::string& channel() const;
  void set_channel(const ::std::string& value);
  #if LANG_CXX11
  void set_channel(::std::string&& value);
  #endif
  void set_channel(const char* value);
  void set_channel(const char* value, size_t size);
  ::std::string* mutable_channel();
  ::std::string* release_channel();
  void set_allocated_channel(::std::string* channel);

  // optional .digitalcurrency.DIterm diterm = 3;
  bool has_diterm() const;
  void clear_diterm();
  static const int kDitermFieldNumber = 3;
  private:
  const ::digitalcurrency::DIterm& _internal_diterm() const;
  public:
  const ::digitalcurrency::DIterm& diterm() const;
  ::digitalcurrency::DIterm* release_diterm();
  ::digitalcurrency::DIterm* mutable_diterm();
  void set_allocated_diterm(::digitalcurrency::DIterm* diterm);

  // optional .digitalcurrency.TradingPair tpair = 2;
  bool has_tpair() const;
  void clear_tpair();
  static const int kTpairFieldNumber = 2;
  ::digitalcurrency::TradingPair tpair() const;
  void set_tpair(::digitalcurrency::TradingPair value);

  // @@protoc_insertion_point(class_scope:digitalcurrency.DepthItem)
 private:
  void set_has_channel();
  void clear_has_channel();
  void set_has_tpair();
  void clear_has_tpair();
  void set_has_diterm();
  void clear_has_diterm();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr channel_;
  ::digitalcurrency::DIterm* diterm_;
  int tpair_;
  friend struct ::protobuf_protos_2fcoin_5fquote_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DepthData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:digitalcurrency.DepthData) */ {
 public:
  DepthData();
  virtual ~DepthData();

  DepthData(const DepthData& from);

  inline DepthData& operator=(const DepthData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DepthData(DepthData&& from) noexcept
    : DepthData() {
    *this = ::std::move(from);
  }

  inline DepthData& operator=(DepthData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DepthData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DepthData* internal_default_instance() {
    return reinterpret_cast<const DepthData*>(
               &_DepthData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(DepthData* other);
  friend void swap(DepthData& a, DepthData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DepthData* New() const final {
    return CreateMaybeMessage<DepthData>(NULL);
  }

  DepthData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DepthData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DepthData& from);
  void MergeFrom(const DepthData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DepthData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .digitalcurrency.DepthItem depths = 2;
  int depths_size() const;
  void clear_depths();
  static const int kDepthsFieldNumber = 2;
  ::digitalcurrency::DepthItem* mutable_depths(int index);
  ::google::protobuf::RepeatedPtrField< ::digitalcurrency::DepthItem >*
      mutable_depths();
  const ::digitalcurrency::DepthItem& depths(int index) const;
  ::digitalcurrency::DepthItem* add_depths();
  const ::google::protobuf::RepeatedPtrField< ::digitalcurrency::DepthItem >&
      depths() const;

  // optional .digitalcurrency.Exchange exchange = 1;
  bool has_exchange() const;
  void clear_exchange();
  static const int kExchangeFieldNumber = 1;
  ::digitalcurrency::Exchange exchange() const;
  void set_exchange(::digitalcurrency::Exchange value);

  // @@protoc_insertion_point(class_scope:digitalcurrency.DepthData)
 private:
  void set_has_exchange();
  void clear_has_exchange();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::digitalcurrency::DepthItem > depths_;
  int exchange_;
  friend struct ::protobuf_protos_2fcoin_5fquote_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TradeData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:digitalcurrency.TradeData) */ {
 public:
  TradeData();
  virtual ~TradeData();

  TradeData(const TradeData& from);

  inline TradeData& operator=(const TradeData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TradeData(TradeData&& from) noexcept
    : TradeData() {
    *this = ::std::move(from);
  }

  inline TradeData& operator=(TradeData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TradeData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TradeData* internal_default_instance() {
    return reinterpret_cast<const TradeData*>(
               &_TradeData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(TradeData* other);
  friend void swap(TradeData& a, TradeData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TradeData* New() const final {
    return CreateMaybeMessage<TradeData>(NULL);
  }

  TradeData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TradeData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TradeData& from);
  void MergeFrom(const TradeData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TradeData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double price = 1;
  bool has_price() const;
  void clear_price();
  static const int kPriceFieldNumber = 1;
  double price() const;
  void set_price(double value);

  // optional double amount = 2;
  bool has_amount() const;
  void clear_amount();
  static const int kAmountFieldNumber = 2;
  double amount() const;
  void set_amount(double value);

  // optional int64 timestamp = 3;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:digitalcurrency.TradeData)
 private:
  void set_has_price();
  void clear_has_price();
  void set_has_amount();
  void clear_has_amount();
  void set_has_timestamp();
  void clear_has_timestamp();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double price_;
  double amount_;
  ::google::protobuf::int64 timestamp_;
  friend struct ::protobuf_protos_2fcoin_5fquote_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KlineData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:digitalcurrency.KlineData) */ {
 public:
  KlineData();
  virtual ~KlineData();

  KlineData(const KlineData& from);

  inline KlineData& operator=(const KlineData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KlineData(KlineData&& from) noexcept
    : KlineData() {
    *this = ::std::move(from);
  }

  inline KlineData& operator=(KlineData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KlineData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KlineData* internal_default_instance() {
    return reinterpret_cast<const KlineData*>(
               &_KlineData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(KlineData* other);
  friend void swap(KlineData& a, KlineData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KlineData* New() const final {
    return CreateMaybeMessage<KlineData>(NULL);
  }

  KlineData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<KlineData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const KlineData& from);
  void MergeFrom(const KlineData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KlineData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 open_time = 1;
  bool has_open_time() const;
  void clear_open_time();
  static const int kOpenTimeFieldNumber = 1;
  ::google::protobuf::int64 open_time() const;
  void set_open_time(::google::protobuf::int64 value);

  // optional double open_price = 2;
  bool has_open_price() const;
  void clear_open_price();
  static const int kOpenPriceFieldNumber = 2;
  double open_price() const;
  void set_open_price(double value);

  // optional double high_price = 3;
  bool has_high_price() const;
  void clear_high_price();
  static const int kHighPriceFieldNumber = 3;
  double high_price() const;
  void set_high_price(double value);

  // optional double low_price = 4;
  bool has_low_price() const;
  void clear_low_price();
  static const int kLowPriceFieldNumber = 4;
  double low_price() const;
  void set_low_price(double value);

  // optional double close_price = 5;
  bool has_close_price() const;
  void clear_close_price();
  static const int kClosePriceFieldNumber = 5;
  double close_price() const;
  void set_close_price(double value);

  // optional int64 close_time = 6;
  bool has_close_time() const;
  void clear_close_time();
  static const int kCloseTimeFieldNumber = 6;
  ::google::protobuf::int64 close_time() const;
  void set_close_time(::google::protobuf::int64 value);

  // optional double volumn = 7;
  bool has_volumn() const;
  void clear_volumn();
  static const int kVolumnFieldNumber = 7;
  double volumn() const;
  void set_volumn(double value);

  // optional int64 number = 8;
  bool has_number() const;
  void clear_number();
  static const int kNumberFieldNumber = 8;
  ::google::protobuf::int64 number() const;
  void set_number(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:digitalcurrency.KlineData)
 private:
  void set_has_open_time();
  void clear_has_open_time();
  void set_has_open_price();
  void clear_has_open_price();
  void set_has_high_price();
  void clear_has_high_price();
  void set_has_low_price();
  void clear_has_low_price();
  void set_has_close_price();
  void clear_has_close_price();
  void set_has_close_time();
  void clear_has_close_time();
  void set_has_volumn();
  void clear_has_volumn();
  void set_has_number();
  void clear_has_number();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int64 open_time_;
  double open_price_;
  double high_price_;
  double low_price_;
  double close_price_;
  ::google::protobuf::int64 close_time_;
  double volumn_;
  ::google::protobuf::int64 number_;
  friend struct ::protobuf_protos_2fcoin_5fquote_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PriceData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:digitalcurrency.PriceData) */ {
 public:
  PriceData();
  virtual ~PriceData();

  PriceData(const PriceData& from);

  inline PriceData& operator=(const PriceData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PriceData(PriceData&& from) noexcept
    : PriceData() {
    *this = ::std::move(from);
  }

  inline PriceData& operator=(PriceData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PriceData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PriceData* internal_default_instance() {
    return reinterpret_cast<const PriceData*>(
               &_PriceData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(PriceData* other);
  friend void swap(PriceData& a, PriceData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PriceData* New() const final {
    return CreateMaybeMessage<PriceData>(NULL);
  }

  PriceData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PriceData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PriceData& from);
  void MergeFrom(const PriceData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PriceData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double price = 2;
  bool has_price() const;
  void clear_price();
  static const int kPriceFieldNumber = 2;
  double price() const;
  void set_price(double value);

  // required .digitalcurrency.TradingPair tpair = 1;
  bool has_tpair() const;
  void clear_tpair();
  static const int kTpairFieldNumber = 1;
  ::digitalcurrency::TradingPair tpair() const;
  void set_tpair(::digitalcurrency::TradingPair value);

  // @@protoc_insertion_point(class_scope:digitalcurrency.PriceData)
 private:
  void set_has_tpair();
  void clear_has_tpair();
  void set_has_price();
  void clear_has_price();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double price_;
  int tpair_;
  friend struct ::protobuf_protos_2fcoin_5fquote_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OrderData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:digitalcurrency.OrderData) */ {
 public:
  OrderData();
  virtual ~OrderData();

  OrderData(const OrderData& from);

  inline OrderData& operator=(const OrderData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OrderData(OrderData&& from) noexcept
    : OrderData() {
    *this = ::std::move(from);
  }

  inline OrderData& operator=(OrderData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OrderData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OrderData* internal_default_instance() {
    return reinterpret_cast<const OrderData*>(
               &_OrderData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(OrderData* other);
  friend void swap(OrderData& a, OrderData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OrderData* New() const final {
    return CreateMaybeMessage<OrderData>(NULL);
  }

  OrderData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OrderData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OrderData& from);
  void MergeFrom(const OrderData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 order_id = 1;
  bool has_order_id() const;
  void clear_order_id();
  static const int kOrderIdFieldNumber = 1;
  ::google::protobuf::int64 order_id() const;
  void set_order_id(::google::protobuf::int64 value);

  // required double amount = 4;
  bool has_amount() const;
  void clear_amount();
  static const int kAmountFieldNumber = 4;
  double amount() const;
  void set_amount(double value);

  // required double price = 5;
  bool has_price() const;
  void clear_price();
  static const int kPriceFieldNumber = 5;
  double price() const;
  void set_price(double value);

  // required double deal_amount = 6;
  bool has_deal_amount() const;
  void clear_deal_amount();
  static const int kDealAmountFieldNumber = 6;
  double deal_amount() const;
  void set_deal_amount(double value);

  // required double avg_price = 7;
  bool has_avg_price() const;
  void clear_avg_price();
  static const int kAvgPriceFieldNumber = 7;
  double avg_price() const;
  void set_avg_price(double value);

  // required .digitalcurrency.Exchange exchange = 3;
  bool has_exchange() const;
  void clear_exchange();
  static const int kExchangeFieldNumber = 3;
  ::digitalcurrency::Exchange exchange() const;
  void set_exchange(::digitalcurrency::Exchange value);

  // required .digitalcurrency.OrderStatus status = 2;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 2;
  ::digitalcurrency::OrderStatus status() const;
  void set_status(::digitalcurrency::OrderStatus value);

  // required .digitalcurrency.TradeType order_type = 8;
  bool has_order_type() const;
  void clear_order_type();
  static const int kOrderTypeFieldNumber = 8;
  ::digitalcurrency::TradeType order_type() const;
  void set_order_type(::digitalcurrency::TradeType value);

  // @@protoc_insertion_point(class_scope:digitalcurrency.OrderData)
 private:
  void set_has_order_id();
  void clear_has_order_id();
  void set_has_status();
  void clear_has_status();
  void set_has_exchange();
  void clear_has_exchange();
  void set_has_amount();
  void clear_has_amount();
  void set_has_price();
  void clear_has_price();
  void set_has_deal_amount();
  void clear_has_deal_amount();
  void set_has_avg_price();
  void clear_has_avg_price();
  void set_has_order_type();
  void clear_has_order_type();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int64 order_id_;
  double amount_;
  double price_;
  double deal_amount_;
  double avg_price_;
  int exchange_;
  int status_;
  int order_type_;
  friend struct ::protobuf_protos_2fcoin_5fquote_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReqDepth : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:digitalcurrency.ReqDepth) */ {
 public:
  ReqDepth();
  virtual ~ReqDepth();

  ReqDepth(const ReqDepth& from);

  inline ReqDepth& operator=(const ReqDepth& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReqDepth(ReqDepth&& from) noexcept
    : ReqDepth() {
    *this = ::std::move(from);
  }

  inline ReqDepth& operator=(ReqDepth&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqDepth& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReqDepth* internal_default_instance() {
    return reinterpret_cast<const ReqDepth*>(
               &_ReqDepth_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(ReqDepth* other);
  friend void swap(ReqDepth& a, ReqDepth& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReqDepth* New() const final {
    return CreateMaybeMessage<ReqDepth>(NULL);
  }

  ReqDepth* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReqDepth>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReqDepth& from);
  void MergeFrom(const ReqDepth& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqDepth* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .digitalcurrency.Exchange exchange = 1;
  bool has_exchange() const;
  void clear_exchange();
  static const int kExchangeFieldNumber = 1;
  ::digitalcurrency::Exchange exchange() const;
  void set_exchange(::digitalcurrency::Exchange value);

  // required .digitalcurrency.TradingPair tpair = 2;
  bool has_tpair() const;
  void clear_tpair();
  static const int kTpairFieldNumber = 2;
  ::digitalcurrency::TradingPair tpair() const;
  void set_tpair(::digitalcurrency::TradingPair value);

  // optional int64 limit = 3;
  bool has_limit() const;
  void clear_limit();
  static const int kLimitFieldNumber = 3;
  ::google::protobuf::int64 limit() const;
  void set_limit(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:digitalcurrency.ReqDepth)
 private:
  void set_has_exchange();
  void clear_has_exchange();
  void set_has_tpair();
  void clear_has_tpair();
  void set_has_limit();
  void clear_has_limit();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int exchange_;
  int tpair_;
  ::google::protobuf::int64 limit_;
  friend struct ::protobuf_protos_2fcoin_5fquote_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RespDepth : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:digitalcurrency.RespDepth) */ {
 public:
  RespDepth();
  virtual ~RespDepth();

  RespDepth(const RespDepth& from);

  inline RespDepth& operator=(const RespDepth& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RespDepth(RespDepth&& from) noexcept
    : RespDepth() {
    *this = ::std::move(from);
  }

  inline RespDepth& operator=(RespDepth&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RespDepth& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RespDepth* internal_default_instance() {
    return reinterpret_cast<const RespDepth*>(
               &_RespDepth_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(RespDepth* other);
  friend void swap(RespDepth& a, RespDepth& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RespDepth* New() const final {
    return CreateMaybeMessage<RespDepth>(NULL);
  }

  RespDepth* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RespDepth>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RespDepth& from);
  void MergeFrom(const RespDepth& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RespDepth* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .digitalcurrency.DepthData depth_data = 2;
  bool has_depth_data() const;
  void clear_depth_data();
  static const int kDepthDataFieldNumber = 2;
  private:
  const ::digitalcurrency::DepthData& _internal_depth_data() const;
  public:
  const ::digitalcurrency::DepthData& depth_data() const;
  ::digitalcurrency::DepthData* release_depth_data();
  ::digitalcurrency::DepthData* mutable_depth_data();
  void set_allocated_depth_data(::digitalcurrency::DepthData* depth_data);

  // required int64 error_code = 1;
  bool has_error_code() const;
  void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  ::google::protobuf::int64 error_code() const;
  void set_error_code(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:digitalcurrency.RespDepth)
 private:
  void set_has_error_code();
  void clear_has_error_code();
  void set_has_depth_data();
  void clear_has_depth_data();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::digitalcurrency::DepthData* depth_data_;
  ::google::protobuf::int64 error_code_;
  friend struct ::protobuf_protos_2fcoin_5fquote_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReqTradeList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:digitalcurrency.ReqTradeList) */ {
 public:
  ReqTradeList();
  virtual ~ReqTradeList();

  ReqTradeList(const ReqTradeList& from);

  inline ReqTradeList& operator=(const ReqTradeList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReqTradeList(ReqTradeList&& from) noexcept
    : ReqTradeList() {
    *this = ::std::move(from);
  }

  inline ReqTradeList& operator=(ReqTradeList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqTradeList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReqTradeList* internal_default_instance() {
    return reinterpret_cast<const ReqTradeList*>(
               &_ReqTradeList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(ReqTradeList* other);
  friend void swap(ReqTradeList& a, ReqTradeList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReqTradeList* New() const final {
    return CreateMaybeMessage<ReqTradeList>(NULL);
  }

  ReqTradeList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReqTradeList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReqTradeList& from);
  void MergeFrom(const ReqTradeList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqTradeList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .digitalcurrency.Exchange exchange = 1;
  bool has_exchange() const;
  void clear_exchange();
  static const int kExchangeFieldNumber = 1;
  ::digitalcurrency::Exchange exchange() const;
  void set_exchange(::digitalcurrency::Exchange value);

  // required .digitalcurrency.TradingPair tpair = 2;
  bool has_tpair() const;
  void clear_tpair();
  static const int kTpairFieldNumber = 2;
  ::digitalcurrency::TradingPair tpair() const;
  void set_tpair(::digitalcurrency::TradingPair value);

  // optional int64 limit = 3;
  bool has_limit() const;
  void clear_limit();
  static const int kLimitFieldNumber = 3;
  ::google::protobuf::int64 limit() const;
  void set_limit(::google::protobuf::int64 value);

  // optional int64 begin_time = 4;
  bool has_begin_time() const;
  void clear_begin_time();
  static const int kBeginTimeFieldNumber = 4;
  ::google::protobuf::int64 begin_time() const;
  void set_begin_time(::google::protobuf::int64 value);

  // optional int64 end_time = 5;
  bool has_end_time() const;
  void clear_end_time();
  static const int kEndTimeFieldNumber = 5;
  ::google::protobuf::int64 end_time() const;
  void set_end_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:digitalcurrency.ReqTradeList)
 private:
  void set_has_exchange();
  void clear_has_exchange();
  void set_has_tpair();
  void clear_has_tpair();
  void set_has_limit();
  void clear_has_limit();
  void set_has_begin_time();
  void clear_has_begin_time();
  void set_has_end_time();
  void clear_has_end_time();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int exchange_;
  int tpair_;
  ::google::protobuf::int64 limit_;
  ::google::protobuf::int64 begin_time_;
  ::google::protobuf::int64 end_time_;
  friend struct ::protobuf_protos_2fcoin_5fquote_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RespTradeList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:digitalcurrency.RespTradeList) */ {
 public:
  RespTradeList();
  virtual ~RespTradeList();

  RespTradeList(const RespTradeList& from);

  inline RespTradeList& operator=(const RespTradeList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RespTradeList(RespTradeList&& from) noexcept
    : RespTradeList() {
    *this = ::std::move(from);
  }

  inline RespTradeList& operator=(RespTradeList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RespTradeList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RespTradeList* internal_default_instance() {
    return reinterpret_cast<const RespTradeList*>(
               &_RespTradeList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(RespTradeList* other);
  friend void swap(RespTradeList& a, RespTradeList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RespTradeList* New() const final {
    return CreateMaybeMessage<RespTradeList>(NULL);
  }

  RespTradeList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RespTradeList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RespTradeList& from);
  void MergeFrom(const RespTradeList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RespTradeList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .digitalcurrency.TradeData trade_data = 2;
  int trade_data_size() const;
  void clear_trade_data();
  static const int kTradeDataFieldNumber = 2;
  ::digitalcurrency::TradeData* mutable_trade_data(int index);
  ::google::protobuf::RepeatedPtrField< ::digitalcurrency::TradeData >*
      mutable_trade_data();
  const ::digitalcurrency::TradeData& trade_data(int index) const;
  ::digitalcurrency::TradeData* add_trade_data();
  const ::google::protobuf::RepeatedPtrField< ::digitalcurrency::TradeData >&
      trade_data() const;

  // required int64 error_code = 1;
  bool has_error_code() const;
  void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  ::google::protobuf::int64 error_code() const;
  void set_error_code(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:digitalcurrency.RespTradeList)
 private:
  void set_has_error_code();
  void clear_has_error_code();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::digitalcurrency::TradeData > trade_data_;
  ::google::protobuf::int64 error_code_;
  friend struct ::protobuf_protos_2fcoin_5fquote_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReqKline : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:digitalcurrency.ReqKline) */ {
 public:
  ReqKline();
  virtual ~ReqKline();

  ReqKline(const ReqKline& from);

  inline ReqKline& operator=(const ReqKline& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReqKline(ReqKline&& from) noexcept
    : ReqKline() {
    *this = ::std::move(from);
  }

  inline ReqKline& operator=(ReqKline&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqKline& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReqKline* internal_default_instance() {
    return reinterpret_cast<const ReqKline*>(
               &_ReqKline_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(ReqKline* other);
  friend void swap(ReqKline& a, ReqKline& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReqKline* New() const final {
    return CreateMaybeMessage<ReqKline>(NULL);
  }

  ReqKline* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReqKline>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReqKline& from);
  void MergeFrom(const ReqKline& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqKline* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .digitalcurrency.Exchange exchange = 1;
  bool has_exchange() const;
  void clear_exchange();
  static const int kExchangeFieldNumber = 1;
  ::digitalcurrency::Exchange exchange() const;
  void set_exchange(::digitalcurrency::Exchange value);

  // required .digitalcurrency.TradingPair tpair = 2;
  bool has_tpair() const;
  void clear_tpair();
  static const int kTpairFieldNumber = 2;
  ::digitalcurrency::TradingPair tpair() const;
  void set_tpair(::digitalcurrency::TradingPair value);

  // optional int64 begin_time = 4;
  bool has_begin_time() const;
  void clear_begin_time();
  static const int kBeginTimeFieldNumber = 4;
  ::google::protobuf::int64 begin_time() const;
  void set_begin_time(::google::protobuf::int64 value);

  // optional int64 end_time = 5;
  bool has_end_time() const;
  void clear_end_time();
  static const int kEndTimeFieldNumber = 5;
  ::google::protobuf::int64 end_time() const;
  void set_end_time(::google::protobuf::int64 value);

  // required .digitalcurrency.KlineInterval kline_type = 3;
  bool has_kline_type() const;
  void clear_kline_type();
  static const int kKlineTypeFieldNumber = 3;
  ::digitalcurrency::KlineInterval kline_type() const;
  void set_kline_type(::digitalcurrency::KlineInterval value);

  // @@protoc_insertion_point(class_scope:digitalcurrency.ReqKline)
 private:
  void set_has_exchange();
  void clear_has_exchange();
  void set_has_tpair();
  void clear_has_tpair();
  void set_has_kline_type();
  void clear_has_kline_type();
  void set_has_begin_time();
  void clear_has_begin_time();
  void set_has_end_time();
  void clear_has_end_time();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int exchange_;
  int tpair_;
  ::google::protobuf::int64 begin_time_;
  ::google::protobuf::int64 end_time_;
  int kline_type_;
  friend struct ::protobuf_protos_2fcoin_5fquote_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RespKline : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:digitalcurrency.RespKline) */ {
 public:
  RespKline();
  virtual ~RespKline();

  RespKline(const RespKline& from);

  inline RespKline& operator=(const RespKline& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RespKline(RespKline&& from) noexcept
    : RespKline() {
    *this = ::std::move(from);
  }

  inline RespKline& operator=(RespKline&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RespKline& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RespKline* internal_default_instance() {
    return reinterpret_cast<const RespKline*>(
               &_RespKline_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(RespKline* other);
  friend void swap(RespKline& a, RespKline& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RespKline* New() const final {
    return CreateMaybeMessage<RespKline>(NULL);
  }

  RespKline* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RespKline>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RespKline& from);
  void MergeFrom(const RespKline& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RespKline* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .digitalcurrency.KlineData kline_data = 2;
  int kline_data_size() const;
  void clear_kline_data();
  static const int kKlineDataFieldNumber = 2;
  ::digitalcurrency::KlineData* mutable_kline_data(int index);
  ::google::protobuf::RepeatedPtrField< ::digitalcurrency::KlineData >*
      mutable_kline_data();
  const ::digitalcurrency::KlineData& kline_data(int index) const;
  ::digitalcurrency::KlineData* add_kline_data();
  const ::google::protobuf::RepeatedPtrField< ::digitalcurrency::KlineData >&
      kline_data() const;

  // required int64 error_code = 1;
  bool has_error_code() const;
  void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  ::google::protobuf::int64 error_code() const;
  void set_error_code(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:digitalcurrency.RespKline)
 private:
  void set_has_error_code();
  void clear_has_error_code();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::digitalcurrency::KlineData > kline_data_;
  ::google::protobuf::int64 error_code_;
  friend struct ::protobuf_protos_2fcoin_5fquote_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReqPrice : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:digitalcurrency.ReqPrice) */ {
 public:
  ReqPrice();
  virtual ~ReqPrice();

  ReqPrice(const ReqPrice& from);

  inline ReqPrice& operator=(const ReqPrice& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReqPrice(ReqPrice&& from) noexcept
    : ReqPrice() {
    *this = ::std::move(from);
  }

  inline ReqPrice& operator=(ReqPrice&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqPrice& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReqPrice* internal_default_instance() {
    return reinterpret_cast<const ReqPrice*>(
               &_ReqPrice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(ReqPrice* other);
  friend void swap(ReqPrice& a, ReqPrice& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReqPrice* New() const final {
    return CreateMaybeMessage<ReqPrice>(NULL);
  }

  ReqPrice* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReqPrice>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReqPrice& from);
  void MergeFrom(const ReqPrice& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqPrice* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .digitalcurrency.Exchange exchange = 1;
  bool has_exchange() const;
  void clear_exchange();
  static const int kExchangeFieldNumber = 1;
  ::digitalcurrency::Exchange exchange() const;
  void set_exchange(::digitalcurrency::Exchange value);

  // optional .digitalcurrency.TradingPair tpair = 2;
  bool has_tpair() const;
  void clear_tpair();
  static const int kTpairFieldNumber = 2;
  ::digitalcurrency::TradingPair tpair() const;
  void set_tpair(::digitalcurrency::TradingPair value);

  // @@protoc_insertion_point(class_scope:digitalcurrency.ReqPrice)
 private:
  void set_has_exchange();
  void clear_has_exchange();
  void set_has_tpair();
  void clear_has_tpair();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int exchange_;
  int tpair_;
  friend struct ::protobuf_protos_2fcoin_5fquote_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RespPrice : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:digitalcurrency.RespPrice) */ {
 public:
  RespPrice();
  virtual ~RespPrice();

  RespPrice(const RespPrice& from);

  inline RespPrice& operator=(const RespPrice& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RespPrice(RespPrice&& from) noexcept
    : RespPrice() {
    *this = ::std::move(from);
  }

  inline RespPrice& operator=(RespPrice&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RespPrice& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RespPrice* internal_default_instance() {
    return reinterpret_cast<const RespPrice*>(
               &_RespPrice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(RespPrice* other);
  friend void swap(RespPrice& a, RespPrice& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RespPrice* New() const final {
    return CreateMaybeMessage<RespPrice>(NULL);
  }

  RespPrice* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RespPrice>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RespPrice& from);
  void MergeFrom(const RespPrice& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RespPrice* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .digitalcurrency.PriceData price_data = 2;
  int price_data_size() const;
  void clear_price_data();
  static const int kPriceDataFieldNumber = 2;
  ::digitalcurrency::PriceData* mutable_price_data(int index);
  ::google::protobuf::RepeatedPtrField< ::digitalcurrency::PriceData >*
      mutable_price_data();
  const ::digitalcurrency::PriceData& price_data(int index) const;
  ::digitalcurrency::PriceData* add_price_data();
  const ::google::protobuf::RepeatedPtrField< ::digitalcurrency::PriceData >&
      price_data() const;

  // required int64 error_code = 1;
  bool has_error_code() const;
  void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  ::google::protobuf::int64 error_code() const;
  void set_error_code(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:digitalcurrency.RespPrice)
 private:
  void set_has_error_code();
  void clear_has_error_code();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::digitalcurrency::PriceData > price_data_;
  ::google::protobuf::int64 error_code_;
  friend struct ::protobuf_protos_2fcoin_5fquote_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReqNewTrade : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:digitalcurrency.ReqNewTrade) */ {
 public:
  ReqNewTrade();
  virtual ~ReqNewTrade();

  ReqNewTrade(const ReqNewTrade& from);

  inline ReqNewTrade& operator=(const ReqNewTrade& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReqNewTrade(ReqNewTrade&& from) noexcept
    : ReqNewTrade() {
    *this = ::std::move(from);
  }

  inline ReqNewTrade& operator=(ReqNewTrade&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqNewTrade& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReqNewTrade* internal_default_instance() {
    return reinterpret_cast<const ReqNewTrade*>(
               &_ReqNewTrade_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(ReqNewTrade* other);
  friend void swap(ReqNewTrade& a, ReqNewTrade& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReqNewTrade* New() const final {
    return CreateMaybeMessage<ReqNewTrade>(NULL);
  }

  ReqNewTrade* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReqNewTrade>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReqNewTrade& from);
  void MergeFrom(const ReqNewTrade& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqNewTrade* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .digitalcurrency.Exchange exchange = 1;
  bool has_exchange() const;
  void clear_exchange();
  static const int kExchangeFieldNumber = 1;
  ::digitalcurrency::Exchange exchange() const;
  void set_exchange(::digitalcurrency::Exchange value);

  // required .digitalcurrency.TradingPair tpair = 2;
  bool has_tpair() const;
  void clear_tpair();
  static const int kTpairFieldNumber = 2;
  ::digitalcurrency::TradingPair tpair() const;
  void set_tpair(::digitalcurrency::TradingPair value);

  // required double price = 4;
  bool has_price() const;
  void clear_price();
  static const int kPriceFieldNumber = 4;
  double price() const;
  void set_price(double value);

  // required double amount = 5;
  bool has_amount() const;
  void clear_amount();
  static const int kAmountFieldNumber = 5;
  double amount() const;
  void set_amount(double value);

  // required .digitalcurrency.TradeType ttype = 3;
  bool has_ttype() const;
  void clear_ttype();
  static const int kTtypeFieldNumber = 3;
  ::digitalcurrency::TradeType ttype() const;
  void set_ttype(::digitalcurrency::TradeType value);

  // @@protoc_insertion_point(class_scope:digitalcurrency.ReqNewTrade)
 private:
  void set_has_exchange();
  void clear_has_exchange();
  void set_has_tpair();
  void clear_has_tpair();
  void set_has_ttype();
  void clear_has_ttype();
  void set_has_price();
  void clear_has_price();
  void set_has_amount();
  void clear_has_amount();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int exchange_;
  int tpair_;
  double price_;
  double amount_;
  int ttype_;
  friend struct ::protobuf_protos_2fcoin_5fquote_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RespNewTrade : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:digitalcurrency.RespNewTrade) */ {
 public:
  RespNewTrade();
  virtual ~RespNewTrade();

  RespNewTrade(const RespNewTrade& from);

  inline RespNewTrade& operator=(const RespNewTrade& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RespNewTrade(RespNewTrade&& from) noexcept
    : RespNewTrade() {
    *this = ::std::move(from);
  }

  inline RespNewTrade& operator=(RespNewTrade&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RespNewTrade& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RespNewTrade* internal_default_instance() {
    return reinterpret_cast<const RespNewTrade*>(
               &_RespNewTrade_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(RespNewTrade* other);
  friend void swap(RespNewTrade& a, RespNewTrade& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RespNewTrade* New() const final {
    return CreateMaybeMessage<RespNewTrade>(NULL);
  }

  RespNewTrade* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RespNewTrade>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RespNewTrade& from);
  void MergeFrom(const RespNewTrade& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RespNewTrade* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 error_code = 1;
  bool has_error_code() const;
  void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  ::google::protobuf::int64 error_code() const;
  void set_error_code(::google::protobuf::int64 value);

  // optional int64 order_id = 2;
  bool has_order_id() const;
  void clear_order_id();
  static const int kOrderIdFieldNumber = 2;
  ::google::protobuf::int64 order_id() const;
  void set_order_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:digitalcurrency.RespNewTrade)
 private:
  void set_has_error_code();
  void clear_has_error_code();
  void set_has_order_id();
  void clear_has_order_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int64 error_code_;
  ::google::protobuf::int64 order_id_;
  friend struct ::protobuf_protos_2fcoin_5fquote_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReqCancelTrade : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:digitalcurrency.ReqCancelTrade) */ {
 public:
  ReqCancelTrade();
  virtual ~ReqCancelTrade();

  ReqCancelTrade(const ReqCancelTrade& from);

  inline ReqCancelTrade& operator=(const ReqCancelTrade& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReqCancelTrade(ReqCancelTrade&& from) noexcept
    : ReqCancelTrade() {
    *this = ::std::move(from);
  }

  inline ReqCancelTrade& operator=(ReqCancelTrade&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqCancelTrade& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReqCancelTrade* internal_default_instance() {
    return reinterpret_cast<const ReqCancelTrade*>(
               &_ReqCancelTrade_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(ReqCancelTrade* other);
  friend void swap(ReqCancelTrade& a, ReqCancelTrade& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReqCancelTrade* New() const final {
    return CreateMaybeMessage<ReqCancelTrade>(NULL);
  }

  ReqCancelTrade* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReqCancelTrade>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReqCancelTrade& from);
  void MergeFrom(const ReqCancelTrade& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqCancelTrade* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 order_id = 2;
  bool has_order_id() const;
  void clear_order_id();
  static const int kOrderIdFieldNumber = 2;
  ::google::protobuf::int64 order_id() const;
  void set_order_id(::google::protobuf::int64 value);

  // required .digitalcurrency.Exchange exchange = 1;
  bool has_exchange() const;
  void clear_exchange();
  static const int kExchangeFieldNumber = 1;
  ::digitalcurrency::Exchange exchange() const;
  void set_exchange(::digitalcurrency::Exchange value);

  // @@protoc_insertion_point(class_scope:digitalcurrency.ReqCancelTrade)
 private:
  void set_has_exchange();
  void clear_has_exchange();
  void set_has_order_id();
  void clear_has_order_id();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int64 order_id_;
  int exchange_;
  friend struct ::protobuf_protos_2fcoin_5fquote_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RespCancelTrade : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:digitalcurrency.RespCancelTrade) */ {
 public:
  RespCancelTrade();
  virtual ~RespCancelTrade();

  RespCancelTrade(const RespCancelTrade& from);

  inline RespCancelTrade& operator=(const RespCancelTrade& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RespCancelTrade(RespCancelTrade&& from) noexcept
    : RespCancelTrade() {
    *this = ::std::move(from);
  }

  inline RespCancelTrade& operator=(RespCancelTrade&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RespCancelTrade& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RespCancelTrade* internal_default_instance() {
    return reinterpret_cast<const RespCancelTrade*>(
               &_RespCancelTrade_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(RespCancelTrade* other);
  friend void swap(RespCancelTrade& a, RespCancelTrade& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RespCancelTrade* New() const final {
    return CreateMaybeMessage<RespCancelTrade>(NULL);
  }

  RespCancelTrade* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RespCancelTrade>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RespCancelTrade& from);
  void MergeFrom(const RespCancelTrade& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RespCancelTrade* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 error_code = 1;
  bool has_error_code() const;
  void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  ::google::protobuf::int64 error_code() const;
  void set_error_code(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:digitalcurrency.RespCancelTrade)
 private:
  void set_has_error_code();
  void clear_has_error_code();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int64 error_code_;
  friend struct ::protobuf_protos_2fcoin_5fquote_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReqOrderInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:digitalcurrency.ReqOrderInfo) */ {
 public:
  ReqOrderInfo();
  virtual ~ReqOrderInfo();

  ReqOrderInfo(const ReqOrderInfo& from);

  inline ReqOrderInfo& operator=(const ReqOrderInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReqOrderInfo(ReqOrderInfo&& from) noexcept
    : ReqOrderInfo() {
    *this = ::std::move(from);
  }

  inline ReqOrderInfo& operator=(ReqOrderInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqOrderInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReqOrderInfo* internal_default_instance() {
    return reinterpret_cast<const ReqOrderInfo*>(
               &_ReqOrderInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(ReqOrderInfo* other);
  friend void swap(ReqOrderInfo& a, ReqOrderInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReqOrderInfo* New() const final {
    return CreateMaybeMessage<ReqOrderInfo>(NULL);
  }

  ReqOrderInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReqOrderInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReqOrderInfo& from);
  void MergeFrom(const ReqOrderInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqOrderInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 order_id = 2;
  bool has_order_id() const;
  void clear_order_id();
  static const int kOrderIdFieldNumber = 2;
  ::google::protobuf::int64 order_id() const;
  void set_order_id(::google::protobuf::int64 value);

  // required .digitalcurrency.Exchange exchange = 1;
  bool has_exchange() const;
  void clear_exchange();
  static const int kExchangeFieldNumber = 1;
  ::digitalcurrency::Exchange exchange() const;
  void set_exchange(::digitalcurrency::Exchange value);

  // @@protoc_insertion_point(class_scope:digitalcurrency.ReqOrderInfo)
 private:
  void set_has_exchange();
  void clear_has_exchange();
  void set_has_order_id();
  void clear_has_order_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int64 order_id_;
  int exchange_;
  friend struct ::protobuf_protos_2fcoin_5fquote_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RespOrderInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:digitalcurrency.RespOrderInfo) */ {
 public:
  RespOrderInfo();
  virtual ~RespOrderInfo();

  RespOrderInfo(const RespOrderInfo& from);

  inline RespOrderInfo& operator=(const RespOrderInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RespOrderInfo(RespOrderInfo&& from) noexcept
    : RespOrderInfo() {
    *this = ::std::move(from);
  }

  inline RespOrderInfo& operator=(RespOrderInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RespOrderInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RespOrderInfo* internal_default_instance() {
    return reinterpret_cast<const RespOrderInfo*>(
               &_RespOrderInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(RespOrderInfo* other);
  friend void swap(RespOrderInfo& a, RespOrderInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RespOrderInfo* New() const final {
    return CreateMaybeMessage<RespOrderInfo>(NULL);
  }

  RespOrderInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RespOrderInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RespOrderInfo& from);
  void MergeFrom(const RespOrderInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RespOrderInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .digitalcurrency.OrderData order_data = 2;
  int order_data_size() const;
  void clear_order_data();
  static const int kOrderDataFieldNumber = 2;
  ::digitalcurrency::OrderData* mutable_order_data(int index);
  ::google::protobuf::RepeatedPtrField< ::digitalcurrency::OrderData >*
      mutable_order_data();
  const ::digitalcurrency::OrderData& order_data(int index) const;
  ::digitalcurrency::OrderData* add_order_data();
  const ::google::protobuf::RepeatedPtrField< ::digitalcurrency::OrderData >&
      order_data() const;

  // required int64 error_code = 1;
  bool has_error_code() const;
  void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  ::google::protobuf::int64 error_code() const;
  void set_error_code(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:digitalcurrency.RespOrderInfo)
 private:
  void set_has_error_code();
  void clear_has_error_code();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::digitalcurrency::OrderData > order_data_;
  ::google::protobuf::int64 error_code_;
  friend struct ::protobuf_protos_2fcoin_5fquote_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TIterm

// optional int64 timestamp = 1;
inline bool TIterm::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TIterm::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TIterm::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TIterm::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 TIterm::timestamp() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.TIterm.timestamp)
  return timestamp_;
}
inline void TIterm::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.TIterm.timestamp)
}

// optional int64 high = 2;
inline bool TIterm::has_high() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TIterm::set_has_high() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TIterm::clear_has_high() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TIterm::clear_high() {
  high_ = GOOGLE_LONGLONG(0);
  clear_has_high();
}
inline ::google::protobuf::int64 TIterm::high() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.TIterm.high)
  return high_;
}
inline void TIterm::set_high(::google::protobuf::int64 value) {
  set_has_high();
  high_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.TIterm.high)
}

// optional int64 low = 3;
inline bool TIterm::has_low() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TIterm::set_has_low() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TIterm::clear_has_low() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TIterm::clear_low() {
  low_ = GOOGLE_LONGLONG(0);
  clear_has_low();
}
inline ::google::protobuf::int64 TIterm::low() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.TIterm.low)
  return low_;
}
inline void TIterm::set_low(::google::protobuf::int64 value) {
  set_has_low();
  low_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.TIterm.low)
}

// optional int64 dayHigh = 4;
inline bool TIterm::has_dayhigh() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TIterm::set_has_dayhigh() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TIterm::clear_has_dayhigh() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TIterm::clear_dayhigh() {
  dayhigh_ = GOOGLE_LONGLONG(0);
  clear_has_dayhigh();
}
inline ::google::protobuf::int64 TIterm::dayhigh() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.TIterm.dayHigh)
  return dayhigh_;
}
inline void TIterm::set_dayhigh(::google::protobuf::int64 value) {
  set_has_dayhigh();
  dayhigh_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.TIterm.dayHigh)
}

// optional int64 dayLow = 5;
inline bool TIterm::has_daylow() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TIterm::set_has_daylow() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TIterm::clear_has_daylow() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TIterm::clear_daylow() {
  daylow_ = GOOGLE_LONGLONG(0);
  clear_has_daylow();
}
inline ::google::protobuf::int64 TIterm::daylow() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.TIterm.dayLow)
  return daylow_;
}
inline void TIterm::set_daylow(::google::protobuf::int64 value) {
  set_has_daylow();
  daylow_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.TIterm.dayLow)
}

// optional int64 vol = 6;
inline bool TIterm::has_vol() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TIterm::set_has_vol() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TIterm::clear_has_vol() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TIterm::clear_vol() {
  vol_ = GOOGLE_LONGLONG(0);
  clear_has_vol();
}
inline ::google::protobuf::int64 TIterm::vol() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.TIterm.vol)
  return vol_;
}
inline void TIterm::set_vol(::google::protobuf::int64 value) {
  set_has_vol();
  vol_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.TIterm.vol)
}

// optional int64 last = 7;
inline bool TIterm::has_last() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TIterm::set_has_last() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TIterm::clear_has_last() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TIterm::clear_last() {
  last_ = GOOGLE_LONGLONG(0);
  clear_has_last();
}
inline ::google::protobuf::int64 TIterm::last() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.TIterm.last)
  return last_;
}
inline void TIterm::set_last(::google::protobuf::int64 value) {
  set_has_last();
  last_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.TIterm.last)
}

// optional int64 buy = 8;
inline bool TIterm::has_buy() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TIterm::set_has_buy() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TIterm::clear_has_buy() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TIterm::clear_buy() {
  buy_ = GOOGLE_LONGLONG(0);
  clear_has_buy();
}
inline ::google::protobuf::int64 TIterm::buy() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.TIterm.buy)
  return buy_;
}
inline void TIterm::set_buy(::google::protobuf::int64 value) {
  set_has_buy();
  buy_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.TIterm.buy)
}

// optional int64 sell = 9;
inline bool TIterm::has_sell() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TIterm::set_has_sell() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TIterm::clear_has_sell() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TIterm::clear_sell() {
  sell_ = GOOGLE_LONGLONG(0);
  clear_has_sell();
}
inline ::google::protobuf::int64 TIterm::sell() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.TIterm.sell)
  return sell_;
}
inline void TIterm::set_sell(::google::protobuf::int64 value) {
  set_has_sell();
  sell_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.TIterm.sell)
}

// optional int64 change = 10;
inline bool TIterm::has_change() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TIterm::set_has_change() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TIterm::clear_has_change() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TIterm::clear_change() {
  change_ = GOOGLE_LONGLONG(0);
  clear_has_change();
}
inline ::google::protobuf::int64 TIterm::change() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.TIterm.change)
  return change_;
}
inline void TIterm::set_change(::google::protobuf::int64 value) {
  set_has_change();
  change_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.TIterm.change)
}

// -------------------------------------------------------------------

// TickerItem

// optional string channel = 1;
inline bool TickerItem::has_channel() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TickerItem::set_has_channel() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TickerItem::clear_has_channel() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TickerItem::clear_channel() {
  channel_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_channel();
}
inline const ::std::string& TickerItem::channel() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.TickerItem.channel)
  return channel_.GetNoArena();
}
inline void TickerItem::set_channel(const ::std::string& value) {
  set_has_channel();
  channel_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:digitalcurrency.TickerItem.channel)
}
#if LANG_CXX11
inline void TickerItem::set_channel(::std::string&& value) {
  set_has_channel();
  channel_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:digitalcurrency.TickerItem.channel)
}
#endif
inline void TickerItem::set_channel(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_channel();
  channel_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:digitalcurrency.TickerItem.channel)
}
inline void TickerItem::set_channel(const char* value, size_t size) {
  set_has_channel();
  channel_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:digitalcurrency.TickerItem.channel)
}
inline ::std::string* TickerItem::mutable_channel() {
  set_has_channel();
  // @@protoc_insertion_point(field_mutable:digitalcurrency.TickerItem.channel)
  return channel_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TickerItem::release_channel() {
  // @@protoc_insertion_point(field_release:digitalcurrency.TickerItem.channel)
  if (!has_channel()) {
    return NULL;
  }
  clear_has_channel();
  return channel_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TickerItem::set_allocated_channel(::std::string* channel) {
  if (channel != NULL) {
    set_has_channel();
  } else {
    clear_has_channel();
  }
  channel_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), channel);
  // @@protoc_insertion_point(field_set_allocated:digitalcurrency.TickerItem.channel)
}

// optional .digitalcurrency.TradingPair tpair = 2;
inline bool TickerItem::has_tpair() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TickerItem::set_has_tpair() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TickerItem::clear_has_tpair() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TickerItem::clear_tpair() {
  tpair_ = 0;
  clear_has_tpair();
}
inline ::digitalcurrency::TradingPair TickerItem::tpair() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.TickerItem.tpair)
  return static_cast< ::digitalcurrency::TradingPair >(tpair_);
}
inline void TickerItem::set_tpair(::digitalcurrency::TradingPair value) {
  assert(::digitalcurrency::TradingPair_IsValid(value));
  set_has_tpair();
  tpair_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.TickerItem.tpair)
}

// optional .digitalcurrency.TIterm titerm = 3;
inline bool TickerItem::has_titerm() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TickerItem::set_has_titerm() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TickerItem::clear_has_titerm() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TickerItem::clear_titerm() {
  if (titerm_ != NULL) titerm_->Clear();
  clear_has_titerm();
}
inline const ::digitalcurrency::TIterm& TickerItem::_internal_titerm() const {
  return *titerm_;
}
inline const ::digitalcurrency::TIterm& TickerItem::titerm() const {
  const ::digitalcurrency::TIterm* p = titerm_;
  // @@protoc_insertion_point(field_get:digitalcurrency.TickerItem.titerm)
  return p != NULL ? *p : *reinterpret_cast<const ::digitalcurrency::TIterm*>(
      &::digitalcurrency::_TIterm_default_instance_);
}
inline ::digitalcurrency::TIterm* TickerItem::release_titerm() {
  // @@protoc_insertion_point(field_release:digitalcurrency.TickerItem.titerm)
  clear_has_titerm();
  ::digitalcurrency::TIterm* temp = titerm_;
  titerm_ = NULL;
  return temp;
}
inline ::digitalcurrency::TIterm* TickerItem::mutable_titerm() {
  set_has_titerm();
  if (titerm_ == NULL) {
    auto* p = CreateMaybeMessage<::digitalcurrency::TIterm>(GetArenaNoVirtual());
    titerm_ = p;
  }
  // @@protoc_insertion_point(field_mutable:digitalcurrency.TickerItem.titerm)
  return titerm_;
}
inline void TickerItem::set_allocated_titerm(::digitalcurrency::TIterm* titerm) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete titerm_;
  }
  if (titerm) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      titerm = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, titerm, submessage_arena);
    }
    set_has_titerm();
  } else {
    clear_has_titerm();
  }
  titerm_ = titerm;
  // @@protoc_insertion_point(field_set_allocated:digitalcurrency.TickerItem.titerm)
}

// -------------------------------------------------------------------

// TickerData

// optional .digitalcurrency.Exchange exchange = 1;
inline bool TickerData::has_exchange() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TickerData::set_has_exchange() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TickerData::clear_has_exchange() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TickerData::clear_exchange() {
  exchange_ = 0;
  clear_has_exchange();
}
inline ::digitalcurrency::Exchange TickerData::exchange() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.TickerData.exchange)
  return static_cast< ::digitalcurrency::Exchange >(exchange_);
}
inline void TickerData::set_exchange(::digitalcurrency::Exchange value) {
  assert(::digitalcurrency::Exchange_IsValid(value));
  set_has_exchange();
  exchange_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.TickerData.exchange)
}

// repeated .digitalcurrency.TickerItem tickers = 2;
inline int TickerData::tickers_size() const {
  return tickers_.size();
}
inline void TickerData::clear_tickers() {
  tickers_.Clear();
}
inline ::digitalcurrency::TickerItem* TickerData::mutable_tickers(int index) {
  // @@protoc_insertion_point(field_mutable:digitalcurrency.TickerData.tickers)
  return tickers_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::digitalcurrency::TickerItem >*
TickerData::mutable_tickers() {
  // @@protoc_insertion_point(field_mutable_list:digitalcurrency.TickerData.tickers)
  return &tickers_;
}
inline const ::digitalcurrency::TickerItem& TickerData::tickers(int index) const {
  // @@protoc_insertion_point(field_get:digitalcurrency.TickerData.tickers)
  return tickers_.Get(index);
}
inline ::digitalcurrency::TickerItem* TickerData::add_tickers() {
  // @@protoc_insertion_point(field_add:digitalcurrency.TickerData.tickers)
  return tickers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::digitalcurrency::TickerItem >&
TickerData::tickers() const {
  // @@protoc_insertion_point(field_list:digitalcurrency.TickerData.tickers)
  return tickers_;
}

// -------------------------------------------------------------------

// AskBid

// optional int64 price = 1;
inline bool AskBid::has_price() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AskBid::set_has_price() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AskBid::clear_has_price() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AskBid::clear_price() {
  price_ = GOOGLE_LONGLONG(0);
  clear_has_price();
}
inline ::google::protobuf::int64 AskBid::price() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.AskBid.price)
  return price_;
}
inline void AskBid::set_price(::google::protobuf::int64 value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.AskBid.price)
}

// optional int64 amount = 2;
inline bool AskBid::has_amount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AskBid::set_has_amount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AskBid::clear_has_amount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AskBid::clear_amount() {
  amount_ = GOOGLE_LONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::int64 AskBid::amount() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.AskBid.amount)
  return amount_;
}
inline void AskBid::set_amount(::google::protobuf::int64 value) {
  set_has_amount();
  amount_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.AskBid.amount)
}

// -------------------------------------------------------------------

// DIterm

// repeated .digitalcurrency.AskBid asks = 1;
inline int DIterm::asks_size() const {
  return asks_.size();
}
inline void DIterm::clear_asks() {
  asks_.Clear();
}
inline ::digitalcurrency::AskBid* DIterm::mutable_asks(int index) {
  // @@protoc_insertion_point(field_mutable:digitalcurrency.DIterm.asks)
  return asks_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::digitalcurrency::AskBid >*
DIterm::mutable_asks() {
  // @@protoc_insertion_point(field_mutable_list:digitalcurrency.DIterm.asks)
  return &asks_;
}
inline const ::digitalcurrency::AskBid& DIterm::asks(int index) const {
  // @@protoc_insertion_point(field_get:digitalcurrency.DIterm.asks)
  return asks_.Get(index);
}
inline ::digitalcurrency::AskBid* DIterm::add_asks() {
  // @@protoc_insertion_point(field_add:digitalcurrency.DIterm.asks)
  return asks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::digitalcurrency::AskBid >&
DIterm::asks() const {
  // @@protoc_insertion_point(field_list:digitalcurrency.DIterm.asks)
  return asks_;
}

// repeated .digitalcurrency.AskBid bids = 2;
inline int DIterm::bids_size() const {
  return bids_.size();
}
inline void DIterm::clear_bids() {
  bids_.Clear();
}
inline ::digitalcurrency::AskBid* DIterm::mutable_bids(int index) {
  // @@protoc_insertion_point(field_mutable:digitalcurrency.DIterm.bids)
  return bids_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::digitalcurrency::AskBid >*
DIterm::mutable_bids() {
  // @@protoc_insertion_point(field_mutable_list:digitalcurrency.DIterm.bids)
  return &bids_;
}
inline const ::digitalcurrency::AskBid& DIterm::bids(int index) const {
  // @@protoc_insertion_point(field_get:digitalcurrency.DIterm.bids)
  return bids_.Get(index);
}
inline ::digitalcurrency::AskBid* DIterm::add_bids() {
  // @@protoc_insertion_point(field_add:digitalcurrency.DIterm.bids)
  return bids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::digitalcurrency::AskBid >&
DIterm::bids() const {
  // @@protoc_insertion_point(field_list:digitalcurrency.DIterm.bids)
  return bids_;
}

// optional int64 timestamp = 3;
inline bool DIterm::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DIterm::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DIterm::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DIterm::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 DIterm::timestamp() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.DIterm.timestamp)
  return timestamp_;
}
inline void DIterm::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.DIterm.timestamp)
}

// -------------------------------------------------------------------

// DepthItem

// optional string channel = 1;
inline bool DepthItem::has_channel() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DepthItem::set_has_channel() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DepthItem::clear_has_channel() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DepthItem::clear_channel() {
  channel_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_channel();
}
inline const ::std::string& DepthItem::channel() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.DepthItem.channel)
  return channel_.GetNoArena();
}
inline void DepthItem::set_channel(const ::std::string& value) {
  set_has_channel();
  channel_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:digitalcurrency.DepthItem.channel)
}
#if LANG_CXX11
inline void DepthItem::set_channel(::std::string&& value) {
  set_has_channel();
  channel_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:digitalcurrency.DepthItem.channel)
}
#endif
inline void DepthItem::set_channel(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_channel();
  channel_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:digitalcurrency.DepthItem.channel)
}
inline void DepthItem::set_channel(const char* value, size_t size) {
  set_has_channel();
  channel_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:digitalcurrency.DepthItem.channel)
}
inline ::std::string* DepthItem::mutable_channel() {
  set_has_channel();
  // @@protoc_insertion_point(field_mutable:digitalcurrency.DepthItem.channel)
  return channel_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DepthItem::release_channel() {
  // @@protoc_insertion_point(field_release:digitalcurrency.DepthItem.channel)
  if (!has_channel()) {
    return NULL;
  }
  clear_has_channel();
  return channel_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DepthItem::set_allocated_channel(::std::string* channel) {
  if (channel != NULL) {
    set_has_channel();
  } else {
    clear_has_channel();
  }
  channel_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), channel);
  // @@protoc_insertion_point(field_set_allocated:digitalcurrency.DepthItem.channel)
}

// optional .digitalcurrency.TradingPair tpair = 2;
inline bool DepthItem::has_tpair() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DepthItem::set_has_tpair() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DepthItem::clear_has_tpair() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DepthItem::clear_tpair() {
  tpair_ = 0;
  clear_has_tpair();
}
inline ::digitalcurrency::TradingPair DepthItem::tpair() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.DepthItem.tpair)
  return static_cast< ::digitalcurrency::TradingPair >(tpair_);
}
inline void DepthItem::set_tpair(::digitalcurrency::TradingPair value) {
  assert(::digitalcurrency::TradingPair_IsValid(value));
  set_has_tpair();
  tpair_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.DepthItem.tpair)
}

// optional .digitalcurrency.DIterm diterm = 3;
inline bool DepthItem::has_diterm() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DepthItem::set_has_diterm() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DepthItem::clear_has_diterm() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DepthItem::clear_diterm() {
  if (diterm_ != NULL) diterm_->Clear();
  clear_has_diterm();
}
inline const ::digitalcurrency::DIterm& DepthItem::_internal_diterm() const {
  return *diterm_;
}
inline const ::digitalcurrency::DIterm& DepthItem::diterm() const {
  const ::digitalcurrency::DIterm* p = diterm_;
  // @@protoc_insertion_point(field_get:digitalcurrency.DepthItem.diterm)
  return p != NULL ? *p : *reinterpret_cast<const ::digitalcurrency::DIterm*>(
      &::digitalcurrency::_DIterm_default_instance_);
}
inline ::digitalcurrency::DIterm* DepthItem::release_diterm() {
  // @@protoc_insertion_point(field_release:digitalcurrency.DepthItem.diterm)
  clear_has_diterm();
  ::digitalcurrency::DIterm* temp = diterm_;
  diterm_ = NULL;
  return temp;
}
inline ::digitalcurrency::DIterm* DepthItem::mutable_diterm() {
  set_has_diterm();
  if (diterm_ == NULL) {
    auto* p = CreateMaybeMessage<::digitalcurrency::DIterm>(GetArenaNoVirtual());
    diterm_ = p;
  }
  // @@protoc_insertion_point(field_mutable:digitalcurrency.DepthItem.diterm)
  return diterm_;
}
inline void DepthItem::set_allocated_diterm(::digitalcurrency::DIterm* diterm) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete diterm_;
  }
  if (diterm) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      diterm = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, diterm, submessage_arena);
    }
    set_has_diterm();
  } else {
    clear_has_diterm();
  }
  diterm_ = diterm;
  // @@protoc_insertion_point(field_set_allocated:digitalcurrency.DepthItem.diterm)
}

// -------------------------------------------------------------------

// DepthData

// optional .digitalcurrency.Exchange exchange = 1;
inline bool DepthData::has_exchange() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DepthData::set_has_exchange() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DepthData::clear_has_exchange() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DepthData::clear_exchange() {
  exchange_ = 0;
  clear_has_exchange();
}
inline ::digitalcurrency::Exchange DepthData::exchange() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.DepthData.exchange)
  return static_cast< ::digitalcurrency::Exchange >(exchange_);
}
inline void DepthData::set_exchange(::digitalcurrency::Exchange value) {
  assert(::digitalcurrency::Exchange_IsValid(value));
  set_has_exchange();
  exchange_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.DepthData.exchange)
}

// repeated .digitalcurrency.DepthItem depths = 2;
inline int DepthData::depths_size() const {
  return depths_.size();
}
inline void DepthData::clear_depths() {
  depths_.Clear();
}
inline ::digitalcurrency::DepthItem* DepthData::mutable_depths(int index) {
  // @@protoc_insertion_point(field_mutable:digitalcurrency.DepthData.depths)
  return depths_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::digitalcurrency::DepthItem >*
DepthData::mutable_depths() {
  // @@protoc_insertion_point(field_mutable_list:digitalcurrency.DepthData.depths)
  return &depths_;
}
inline const ::digitalcurrency::DepthItem& DepthData::depths(int index) const {
  // @@protoc_insertion_point(field_get:digitalcurrency.DepthData.depths)
  return depths_.Get(index);
}
inline ::digitalcurrency::DepthItem* DepthData::add_depths() {
  // @@protoc_insertion_point(field_add:digitalcurrency.DepthData.depths)
  return depths_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::digitalcurrency::DepthItem >&
DepthData::depths() const {
  // @@protoc_insertion_point(field_list:digitalcurrency.DepthData.depths)
  return depths_;
}

// -------------------------------------------------------------------

// TradeData

// optional double price = 1;
inline bool TradeData::has_price() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TradeData::set_has_price() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TradeData::clear_has_price() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TradeData::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline double TradeData::price() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.TradeData.price)
  return price_;
}
inline void TradeData::set_price(double value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.TradeData.price)
}

// optional double amount = 2;
inline bool TradeData::has_amount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TradeData::set_has_amount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TradeData::clear_has_amount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TradeData::clear_amount() {
  amount_ = 0;
  clear_has_amount();
}
inline double TradeData::amount() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.TradeData.amount)
  return amount_;
}
inline void TradeData::set_amount(double value) {
  set_has_amount();
  amount_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.TradeData.amount)
}

// optional int64 timestamp = 3;
inline bool TradeData::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TradeData::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TradeData::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TradeData::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 TradeData::timestamp() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.TradeData.timestamp)
  return timestamp_;
}
inline void TradeData::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.TradeData.timestamp)
}

// -------------------------------------------------------------------

// KlineData

// optional int64 open_time = 1;
inline bool KlineData::has_open_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KlineData::set_has_open_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KlineData::clear_has_open_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KlineData::clear_open_time() {
  open_time_ = GOOGLE_LONGLONG(0);
  clear_has_open_time();
}
inline ::google::protobuf::int64 KlineData::open_time() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.KlineData.open_time)
  return open_time_;
}
inline void KlineData::set_open_time(::google::protobuf::int64 value) {
  set_has_open_time();
  open_time_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.KlineData.open_time)
}

// optional double open_price = 2;
inline bool KlineData::has_open_price() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KlineData::set_has_open_price() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KlineData::clear_has_open_price() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KlineData::clear_open_price() {
  open_price_ = 0;
  clear_has_open_price();
}
inline double KlineData::open_price() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.KlineData.open_price)
  return open_price_;
}
inline void KlineData::set_open_price(double value) {
  set_has_open_price();
  open_price_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.KlineData.open_price)
}

// optional double high_price = 3;
inline bool KlineData::has_high_price() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void KlineData::set_has_high_price() {
  _has_bits_[0] |= 0x00000004u;
}
inline void KlineData::clear_has_high_price() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void KlineData::clear_high_price() {
  high_price_ = 0;
  clear_has_high_price();
}
inline double KlineData::high_price() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.KlineData.high_price)
  return high_price_;
}
inline void KlineData::set_high_price(double value) {
  set_has_high_price();
  high_price_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.KlineData.high_price)
}

// optional double low_price = 4;
inline bool KlineData::has_low_price() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void KlineData::set_has_low_price() {
  _has_bits_[0] |= 0x00000008u;
}
inline void KlineData::clear_has_low_price() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void KlineData::clear_low_price() {
  low_price_ = 0;
  clear_has_low_price();
}
inline double KlineData::low_price() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.KlineData.low_price)
  return low_price_;
}
inline void KlineData::set_low_price(double value) {
  set_has_low_price();
  low_price_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.KlineData.low_price)
}

// optional double close_price = 5;
inline bool KlineData::has_close_price() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void KlineData::set_has_close_price() {
  _has_bits_[0] |= 0x00000010u;
}
inline void KlineData::clear_has_close_price() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void KlineData::clear_close_price() {
  close_price_ = 0;
  clear_has_close_price();
}
inline double KlineData::close_price() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.KlineData.close_price)
  return close_price_;
}
inline void KlineData::set_close_price(double value) {
  set_has_close_price();
  close_price_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.KlineData.close_price)
}

// optional int64 close_time = 6;
inline bool KlineData::has_close_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void KlineData::set_has_close_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void KlineData::clear_has_close_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void KlineData::clear_close_time() {
  close_time_ = GOOGLE_LONGLONG(0);
  clear_has_close_time();
}
inline ::google::protobuf::int64 KlineData::close_time() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.KlineData.close_time)
  return close_time_;
}
inline void KlineData::set_close_time(::google::protobuf::int64 value) {
  set_has_close_time();
  close_time_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.KlineData.close_time)
}

// optional double volumn = 7;
inline bool KlineData::has_volumn() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void KlineData::set_has_volumn() {
  _has_bits_[0] |= 0x00000040u;
}
inline void KlineData::clear_has_volumn() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void KlineData::clear_volumn() {
  volumn_ = 0;
  clear_has_volumn();
}
inline double KlineData::volumn() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.KlineData.volumn)
  return volumn_;
}
inline void KlineData::set_volumn(double value) {
  set_has_volumn();
  volumn_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.KlineData.volumn)
}

// optional int64 number = 8;
inline bool KlineData::has_number() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void KlineData::set_has_number() {
  _has_bits_[0] |= 0x00000080u;
}
inline void KlineData::clear_has_number() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void KlineData::clear_number() {
  number_ = GOOGLE_LONGLONG(0);
  clear_has_number();
}
inline ::google::protobuf::int64 KlineData::number() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.KlineData.number)
  return number_;
}
inline void KlineData::set_number(::google::protobuf::int64 value) {
  set_has_number();
  number_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.KlineData.number)
}

// -------------------------------------------------------------------

// PriceData

// required .digitalcurrency.TradingPair tpair = 1;
inline bool PriceData::has_tpair() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PriceData::set_has_tpair() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PriceData::clear_has_tpair() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PriceData::clear_tpair() {
  tpair_ = 0;
  clear_has_tpair();
}
inline ::digitalcurrency::TradingPair PriceData::tpair() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.PriceData.tpair)
  return static_cast< ::digitalcurrency::TradingPair >(tpair_);
}
inline void PriceData::set_tpair(::digitalcurrency::TradingPair value) {
  assert(::digitalcurrency::TradingPair_IsValid(value));
  set_has_tpair();
  tpair_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.PriceData.tpair)
}

// required double price = 2;
inline bool PriceData::has_price() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PriceData::set_has_price() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PriceData::clear_has_price() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PriceData::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline double PriceData::price() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.PriceData.price)
  return price_;
}
inline void PriceData::set_price(double value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.PriceData.price)
}

// -------------------------------------------------------------------

// OrderData

// required int64 order_id = 1;
inline bool OrderData::has_order_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OrderData::set_has_order_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OrderData::clear_has_order_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OrderData::clear_order_id() {
  order_id_ = GOOGLE_LONGLONG(0);
  clear_has_order_id();
}
inline ::google::protobuf::int64 OrderData::order_id() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.OrderData.order_id)
  return order_id_;
}
inline void OrderData::set_order_id(::google::protobuf::int64 value) {
  set_has_order_id();
  order_id_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.OrderData.order_id)
}

// required .digitalcurrency.OrderStatus status = 2;
inline bool OrderData::has_status() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void OrderData::set_has_status() {
  _has_bits_[0] |= 0x00000040u;
}
inline void OrderData::clear_has_status() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void OrderData::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::digitalcurrency::OrderStatus OrderData::status() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.OrderData.status)
  return static_cast< ::digitalcurrency::OrderStatus >(status_);
}
inline void OrderData::set_status(::digitalcurrency::OrderStatus value) {
  assert(::digitalcurrency::OrderStatus_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.OrderData.status)
}

// required .digitalcurrency.Exchange exchange = 3;
inline bool OrderData::has_exchange() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void OrderData::set_has_exchange() {
  _has_bits_[0] |= 0x00000020u;
}
inline void OrderData::clear_has_exchange() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void OrderData::clear_exchange() {
  exchange_ = 0;
  clear_has_exchange();
}
inline ::digitalcurrency::Exchange OrderData::exchange() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.OrderData.exchange)
  return static_cast< ::digitalcurrency::Exchange >(exchange_);
}
inline void OrderData::set_exchange(::digitalcurrency::Exchange value) {
  assert(::digitalcurrency::Exchange_IsValid(value));
  set_has_exchange();
  exchange_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.OrderData.exchange)
}

// required double amount = 4;
inline bool OrderData::has_amount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OrderData::set_has_amount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OrderData::clear_has_amount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OrderData::clear_amount() {
  amount_ = 0;
  clear_has_amount();
}
inline double OrderData::amount() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.OrderData.amount)
  return amount_;
}
inline void OrderData::set_amount(double value) {
  set_has_amount();
  amount_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.OrderData.amount)
}

// required double price = 5;
inline bool OrderData::has_price() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OrderData::set_has_price() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OrderData::clear_has_price() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OrderData::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline double OrderData::price() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.OrderData.price)
  return price_;
}
inline void OrderData::set_price(double value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.OrderData.price)
}

// required double deal_amount = 6;
inline bool OrderData::has_deal_amount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OrderData::set_has_deal_amount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OrderData::clear_has_deal_amount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OrderData::clear_deal_amount() {
  deal_amount_ = 0;
  clear_has_deal_amount();
}
inline double OrderData::deal_amount() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.OrderData.deal_amount)
  return deal_amount_;
}
inline void OrderData::set_deal_amount(double value) {
  set_has_deal_amount();
  deal_amount_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.OrderData.deal_amount)
}

// required double avg_price = 7;
inline bool OrderData::has_avg_price() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OrderData::set_has_avg_price() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OrderData::clear_has_avg_price() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OrderData::clear_avg_price() {
  avg_price_ = 0;
  clear_has_avg_price();
}
inline double OrderData::avg_price() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.OrderData.avg_price)
  return avg_price_;
}
inline void OrderData::set_avg_price(double value) {
  set_has_avg_price();
  avg_price_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.OrderData.avg_price)
}

// required .digitalcurrency.TradeType order_type = 8;
inline bool OrderData::has_order_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void OrderData::set_has_order_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void OrderData::clear_has_order_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void OrderData::clear_order_type() {
  order_type_ = 1;
  clear_has_order_type();
}
inline ::digitalcurrency::TradeType OrderData::order_type() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.OrderData.order_type)
  return static_cast< ::digitalcurrency::TradeType >(order_type_);
}
inline void OrderData::set_order_type(::digitalcurrency::TradeType value) {
  assert(::digitalcurrency::TradeType_IsValid(value));
  set_has_order_type();
  order_type_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.OrderData.order_type)
}

// -------------------------------------------------------------------

// ReqDepth

// required .digitalcurrency.Exchange exchange = 1;
inline bool ReqDepth::has_exchange() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqDepth::set_has_exchange() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqDepth::clear_has_exchange() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqDepth::clear_exchange() {
  exchange_ = 0;
  clear_has_exchange();
}
inline ::digitalcurrency::Exchange ReqDepth::exchange() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.ReqDepth.exchange)
  return static_cast< ::digitalcurrency::Exchange >(exchange_);
}
inline void ReqDepth::set_exchange(::digitalcurrency::Exchange value) {
  assert(::digitalcurrency::Exchange_IsValid(value));
  set_has_exchange();
  exchange_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.ReqDepth.exchange)
}

// required .digitalcurrency.TradingPair tpair = 2;
inline bool ReqDepth::has_tpair() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqDepth::set_has_tpair() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqDepth::clear_has_tpair() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqDepth::clear_tpair() {
  tpair_ = 0;
  clear_has_tpair();
}
inline ::digitalcurrency::TradingPair ReqDepth::tpair() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.ReqDepth.tpair)
  return static_cast< ::digitalcurrency::TradingPair >(tpair_);
}
inline void ReqDepth::set_tpair(::digitalcurrency::TradingPair value) {
  assert(::digitalcurrency::TradingPair_IsValid(value));
  set_has_tpair();
  tpair_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.ReqDepth.tpair)
}

// optional int64 limit = 3;
inline bool ReqDepth::has_limit() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqDepth::set_has_limit() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqDepth::clear_has_limit() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqDepth::clear_limit() {
  limit_ = GOOGLE_LONGLONG(0);
  clear_has_limit();
}
inline ::google::protobuf::int64 ReqDepth::limit() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.ReqDepth.limit)
  return limit_;
}
inline void ReqDepth::set_limit(::google::protobuf::int64 value) {
  set_has_limit();
  limit_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.ReqDepth.limit)
}

// -------------------------------------------------------------------

// RespDepth

// required int64 error_code = 1;
inline bool RespDepth::has_error_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RespDepth::set_has_error_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RespDepth::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RespDepth::clear_error_code() {
  error_code_ = GOOGLE_LONGLONG(0);
  clear_has_error_code();
}
inline ::google::protobuf::int64 RespDepth::error_code() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.RespDepth.error_code)
  return error_code_;
}
inline void RespDepth::set_error_code(::google::protobuf::int64 value) {
  set_has_error_code();
  error_code_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.RespDepth.error_code)
}

// required .digitalcurrency.DepthData depth_data = 2;
inline bool RespDepth::has_depth_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RespDepth::set_has_depth_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RespDepth::clear_has_depth_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RespDepth::clear_depth_data() {
  if (depth_data_ != NULL) depth_data_->Clear();
  clear_has_depth_data();
}
inline const ::digitalcurrency::DepthData& RespDepth::_internal_depth_data() const {
  return *depth_data_;
}
inline const ::digitalcurrency::DepthData& RespDepth::depth_data() const {
  const ::digitalcurrency::DepthData* p = depth_data_;
  // @@protoc_insertion_point(field_get:digitalcurrency.RespDepth.depth_data)
  return p != NULL ? *p : *reinterpret_cast<const ::digitalcurrency::DepthData*>(
      &::digitalcurrency::_DepthData_default_instance_);
}
inline ::digitalcurrency::DepthData* RespDepth::release_depth_data() {
  // @@protoc_insertion_point(field_release:digitalcurrency.RespDepth.depth_data)
  clear_has_depth_data();
  ::digitalcurrency::DepthData* temp = depth_data_;
  depth_data_ = NULL;
  return temp;
}
inline ::digitalcurrency::DepthData* RespDepth::mutable_depth_data() {
  set_has_depth_data();
  if (depth_data_ == NULL) {
    auto* p = CreateMaybeMessage<::digitalcurrency::DepthData>(GetArenaNoVirtual());
    depth_data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:digitalcurrency.RespDepth.depth_data)
  return depth_data_;
}
inline void RespDepth::set_allocated_depth_data(::digitalcurrency::DepthData* depth_data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete depth_data_;
  }
  if (depth_data) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      depth_data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, depth_data, submessage_arena);
    }
    set_has_depth_data();
  } else {
    clear_has_depth_data();
  }
  depth_data_ = depth_data;
  // @@protoc_insertion_point(field_set_allocated:digitalcurrency.RespDepth.depth_data)
}

// -------------------------------------------------------------------

// ReqTradeList

// required .digitalcurrency.Exchange exchange = 1;
inline bool ReqTradeList::has_exchange() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqTradeList::set_has_exchange() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqTradeList::clear_has_exchange() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqTradeList::clear_exchange() {
  exchange_ = 0;
  clear_has_exchange();
}
inline ::digitalcurrency::Exchange ReqTradeList::exchange() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.ReqTradeList.exchange)
  return static_cast< ::digitalcurrency::Exchange >(exchange_);
}
inline void ReqTradeList::set_exchange(::digitalcurrency::Exchange value) {
  assert(::digitalcurrency::Exchange_IsValid(value));
  set_has_exchange();
  exchange_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.ReqTradeList.exchange)
}

// required .digitalcurrency.TradingPair tpair = 2;
inline bool ReqTradeList::has_tpair() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqTradeList::set_has_tpair() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqTradeList::clear_has_tpair() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqTradeList::clear_tpair() {
  tpair_ = 0;
  clear_has_tpair();
}
inline ::digitalcurrency::TradingPair ReqTradeList::tpair() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.ReqTradeList.tpair)
  return static_cast< ::digitalcurrency::TradingPair >(tpair_);
}
inline void ReqTradeList::set_tpair(::digitalcurrency::TradingPair value) {
  assert(::digitalcurrency::TradingPair_IsValid(value));
  set_has_tpair();
  tpair_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.ReqTradeList.tpair)
}

// optional int64 limit = 3;
inline bool ReqTradeList::has_limit() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqTradeList::set_has_limit() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqTradeList::clear_has_limit() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqTradeList::clear_limit() {
  limit_ = GOOGLE_LONGLONG(0);
  clear_has_limit();
}
inline ::google::protobuf::int64 ReqTradeList::limit() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.ReqTradeList.limit)
  return limit_;
}
inline void ReqTradeList::set_limit(::google::protobuf::int64 value) {
  set_has_limit();
  limit_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.ReqTradeList.limit)
}

// optional int64 begin_time = 4;
inline bool ReqTradeList::has_begin_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReqTradeList::set_has_begin_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReqTradeList::clear_has_begin_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReqTradeList::clear_begin_time() {
  begin_time_ = GOOGLE_LONGLONG(0);
  clear_has_begin_time();
}
inline ::google::protobuf::int64 ReqTradeList::begin_time() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.ReqTradeList.begin_time)
  return begin_time_;
}
inline void ReqTradeList::set_begin_time(::google::protobuf::int64 value) {
  set_has_begin_time();
  begin_time_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.ReqTradeList.begin_time)
}

// optional int64 end_time = 5;
inline bool ReqTradeList::has_end_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ReqTradeList::set_has_end_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ReqTradeList::clear_has_end_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ReqTradeList::clear_end_time() {
  end_time_ = GOOGLE_LONGLONG(0);
  clear_has_end_time();
}
inline ::google::protobuf::int64 ReqTradeList::end_time() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.ReqTradeList.end_time)
  return end_time_;
}
inline void ReqTradeList::set_end_time(::google::protobuf::int64 value) {
  set_has_end_time();
  end_time_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.ReqTradeList.end_time)
}

// -------------------------------------------------------------------

// RespTradeList

// required int64 error_code = 1;
inline bool RespTradeList::has_error_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RespTradeList::set_has_error_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RespTradeList::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RespTradeList::clear_error_code() {
  error_code_ = GOOGLE_LONGLONG(0);
  clear_has_error_code();
}
inline ::google::protobuf::int64 RespTradeList::error_code() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.RespTradeList.error_code)
  return error_code_;
}
inline void RespTradeList::set_error_code(::google::protobuf::int64 value) {
  set_has_error_code();
  error_code_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.RespTradeList.error_code)
}

// repeated .digitalcurrency.TradeData trade_data = 2;
inline int RespTradeList::trade_data_size() const {
  return trade_data_.size();
}
inline void RespTradeList::clear_trade_data() {
  trade_data_.Clear();
}
inline ::digitalcurrency::TradeData* RespTradeList::mutable_trade_data(int index) {
  // @@protoc_insertion_point(field_mutable:digitalcurrency.RespTradeList.trade_data)
  return trade_data_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::digitalcurrency::TradeData >*
RespTradeList::mutable_trade_data() {
  // @@protoc_insertion_point(field_mutable_list:digitalcurrency.RespTradeList.trade_data)
  return &trade_data_;
}
inline const ::digitalcurrency::TradeData& RespTradeList::trade_data(int index) const {
  // @@protoc_insertion_point(field_get:digitalcurrency.RespTradeList.trade_data)
  return trade_data_.Get(index);
}
inline ::digitalcurrency::TradeData* RespTradeList::add_trade_data() {
  // @@protoc_insertion_point(field_add:digitalcurrency.RespTradeList.trade_data)
  return trade_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::digitalcurrency::TradeData >&
RespTradeList::trade_data() const {
  // @@protoc_insertion_point(field_list:digitalcurrency.RespTradeList.trade_data)
  return trade_data_;
}

// -------------------------------------------------------------------

// ReqKline

// required .digitalcurrency.Exchange exchange = 1;
inline bool ReqKline::has_exchange() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqKline::set_has_exchange() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqKline::clear_has_exchange() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqKline::clear_exchange() {
  exchange_ = 0;
  clear_has_exchange();
}
inline ::digitalcurrency::Exchange ReqKline::exchange() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.ReqKline.exchange)
  return static_cast< ::digitalcurrency::Exchange >(exchange_);
}
inline void ReqKline::set_exchange(::digitalcurrency::Exchange value) {
  assert(::digitalcurrency::Exchange_IsValid(value));
  set_has_exchange();
  exchange_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.ReqKline.exchange)
}

// required .digitalcurrency.TradingPair tpair = 2;
inline bool ReqKline::has_tpair() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqKline::set_has_tpair() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqKline::clear_has_tpair() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqKline::clear_tpair() {
  tpair_ = 0;
  clear_has_tpair();
}
inline ::digitalcurrency::TradingPair ReqKline::tpair() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.ReqKline.tpair)
  return static_cast< ::digitalcurrency::TradingPair >(tpair_);
}
inline void ReqKline::set_tpair(::digitalcurrency::TradingPair value) {
  assert(::digitalcurrency::TradingPair_IsValid(value));
  set_has_tpair();
  tpair_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.ReqKline.tpair)
}

// required .digitalcurrency.KlineInterval kline_type = 3;
inline bool ReqKline::has_kline_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ReqKline::set_has_kline_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ReqKline::clear_has_kline_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ReqKline::clear_kline_type() {
  kline_type_ = 1;
  clear_has_kline_type();
}
inline ::digitalcurrency::KlineInterval ReqKline::kline_type() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.ReqKline.kline_type)
  return static_cast< ::digitalcurrency::KlineInterval >(kline_type_);
}
inline void ReqKline::set_kline_type(::digitalcurrency::KlineInterval value) {
  assert(::digitalcurrency::KlineInterval_IsValid(value));
  set_has_kline_type();
  kline_type_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.ReqKline.kline_type)
}

// optional int64 begin_time = 4;
inline bool ReqKline::has_begin_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqKline::set_has_begin_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqKline::clear_has_begin_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqKline::clear_begin_time() {
  begin_time_ = GOOGLE_LONGLONG(0);
  clear_has_begin_time();
}
inline ::google::protobuf::int64 ReqKline::begin_time() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.ReqKline.begin_time)
  return begin_time_;
}
inline void ReqKline::set_begin_time(::google::protobuf::int64 value) {
  set_has_begin_time();
  begin_time_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.ReqKline.begin_time)
}

// optional int64 end_time = 5;
inline bool ReqKline::has_end_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReqKline::set_has_end_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReqKline::clear_has_end_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReqKline::clear_end_time() {
  end_time_ = GOOGLE_LONGLONG(0);
  clear_has_end_time();
}
inline ::google::protobuf::int64 ReqKline::end_time() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.ReqKline.end_time)
  return end_time_;
}
inline void ReqKline::set_end_time(::google::protobuf::int64 value) {
  set_has_end_time();
  end_time_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.ReqKline.end_time)
}

// -------------------------------------------------------------------

// RespKline

// required int64 error_code = 1;
inline bool RespKline::has_error_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RespKline::set_has_error_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RespKline::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RespKline::clear_error_code() {
  error_code_ = GOOGLE_LONGLONG(0);
  clear_has_error_code();
}
inline ::google::protobuf::int64 RespKline::error_code() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.RespKline.error_code)
  return error_code_;
}
inline void RespKline::set_error_code(::google::protobuf::int64 value) {
  set_has_error_code();
  error_code_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.RespKline.error_code)
}

// repeated .digitalcurrency.KlineData kline_data = 2;
inline int RespKline::kline_data_size() const {
  return kline_data_.size();
}
inline void RespKline::clear_kline_data() {
  kline_data_.Clear();
}
inline ::digitalcurrency::KlineData* RespKline::mutable_kline_data(int index) {
  // @@protoc_insertion_point(field_mutable:digitalcurrency.RespKline.kline_data)
  return kline_data_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::digitalcurrency::KlineData >*
RespKline::mutable_kline_data() {
  // @@protoc_insertion_point(field_mutable_list:digitalcurrency.RespKline.kline_data)
  return &kline_data_;
}
inline const ::digitalcurrency::KlineData& RespKline::kline_data(int index) const {
  // @@protoc_insertion_point(field_get:digitalcurrency.RespKline.kline_data)
  return kline_data_.Get(index);
}
inline ::digitalcurrency::KlineData* RespKline::add_kline_data() {
  // @@protoc_insertion_point(field_add:digitalcurrency.RespKline.kline_data)
  return kline_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::digitalcurrency::KlineData >&
RespKline::kline_data() const {
  // @@protoc_insertion_point(field_list:digitalcurrency.RespKline.kline_data)
  return kline_data_;
}

// -------------------------------------------------------------------

// ReqPrice

// required .digitalcurrency.Exchange exchange = 1;
inline bool ReqPrice::has_exchange() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqPrice::set_has_exchange() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqPrice::clear_has_exchange() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqPrice::clear_exchange() {
  exchange_ = 0;
  clear_has_exchange();
}
inline ::digitalcurrency::Exchange ReqPrice::exchange() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.ReqPrice.exchange)
  return static_cast< ::digitalcurrency::Exchange >(exchange_);
}
inline void ReqPrice::set_exchange(::digitalcurrency::Exchange value) {
  assert(::digitalcurrency::Exchange_IsValid(value));
  set_has_exchange();
  exchange_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.ReqPrice.exchange)
}

// optional .digitalcurrency.TradingPair tpair = 2;
inline bool ReqPrice::has_tpair() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqPrice::set_has_tpair() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqPrice::clear_has_tpair() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqPrice::clear_tpair() {
  tpair_ = 0;
  clear_has_tpair();
}
inline ::digitalcurrency::TradingPair ReqPrice::tpair() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.ReqPrice.tpair)
  return static_cast< ::digitalcurrency::TradingPair >(tpair_);
}
inline void ReqPrice::set_tpair(::digitalcurrency::TradingPair value) {
  assert(::digitalcurrency::TradingPair_IsValid(value));
  set_has_tpair();
  tpair_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.ReqPrice.tpair)
}

// -------------------------------------------------------------------

// RespPrice

// required int64 error_code = 1;
inline bool RespPrice::has_error_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RespPrice::set_has_error_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RespPrice::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RespPrice::clear_error_code() {
  error_code_ = GOOGLE_LONGLONG(0);
  clear_has_error_code();
}
inline ::google::protobuf::int64 RespPrice::error_code() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.RespPrice.error_code)
  return error_code_;
}
inline void RespPrice::set_error_code(::google::protobuf::int64 value) {
  set_has_error_code();
  error_code_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.RespPrice.error_code)
}

// repeated .digitalcurrency.PriceData price_data = 2;
inline int RespPrice::price_data_size() const {
  return price_data_.size();
}
inline void RespPrice::clear_price_data() {
  price_data_.Clear();
}
inline ::digitalcurrency::PriceData* RespPrice::mutable_price_data(int index) {
  // @@protoc_insertion_point(field_mutable:digitalcurrency.RespPrice.price_data)
  return price_data_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::digitalcurrency::PriceData >*
RespPrice::mutable_price_data() {
  // @@protoc_insertion_point(field_mutable_list:digitalcurrency.RespPrice.price_data)
  return &price_data_;
}
inline const ::digitalcurrency::PriceData& RespPrice::price_data(int index) const {
  // @@protoc_insertion_point(field_get:digitalcurrency.RespPrice.price_data)
  return price_data_.Get(index);
}
inline ::digitalcurrency::PriceData* RespPrice::add_price_data() {
  // @@protoc_insertion_point(field_add:digitalcurrency.RespPrice.price_data)
  return price_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::digitalcurrency::PriceData >&
RespPrice::price_data() const {
  // @@protoc_insertion_point(field_list:digitalcurrency.RespPrice.price_data)
  return price_data_;
}

// -------------------------------------------------------------------

// ReqNewTrade

// required .digitalcurrency.Exchange exchange = 1;
inline bool ReqNewTrade::has_exchange() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqNewTrade::set_has_exchange() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqNewTrade::clear_has_exchange() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqNewTrade::clear_exchange() {
  exchange_ = 0;
  clear_has_exchange();
}
inline ::digitalcurrency::Exchange ReqNewTrade::exchange() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.ReqNewTrade.exchange)
  return static_cast< ::digitalcurrency::Exchange >(exchange_);
}
inline void ReqNewTrade::set_exchange(::digitalcurrency::Exchange value) {
  assert(::digitalcurrency::Exchange_IsValid(value));
  set_has_exchange();
  exchange_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.ReqNewTrade.exchange)
}

// required .digitalcurrency.TradingPair tpair = 2;
inline bool ReqNewTrade::has_tpair() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqNewTrade::set_has_tpair() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqNewTrade::clear_has_tpair() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqNewTrade::clear_tpair() {
  tpair_ = 0;
  clear_has_tpair();
}
inline ::digitalcurrency::TradingPair ReqNewTrade::tpair() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.ReqNewTrade.tpair)
  return static_cast< ::digitalcurrency::TradingPair >(tpair_);
}
inline void ReqNewTrade::set_tpair(::digitalcurrency::TradingPair value) {
  assert(::digitalcurrency::TradingPair_IsValid(value));
  set_has_tpair();
  tpair_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.ReqNewTrade.tpair)
}

// required .digitalcurrency.TradeType ttype = 3;
inline bool ReqNewTrade::has_ttype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ReqNewTrade::set_has_ttype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ReqNewTrade::clear_has_ttype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ReqNewTrade::clear_ttype() {
  ttype_ = 1;
  clear_has_ttype();
}
inline ::digitalcurrency::TradeType ReqNewTrade::ttype() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.ReqNewTrade.ttype)
  return static_cast< ::digitalcurrency::TradeType >(ttype_);
}
inline void ReqNewTrade::set_ttype(::digitalcurrency::TradeType value) {
  assert(::digitalcurrency::TradeType_IsValid(value));
  set_has_ttype();
  ttype_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.ReqNewTrade.ttype)
}

// required double price = 4;
inline bool ReqNewTrade::has_price() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqNewTrade::set_has_price() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqNewTrade::clear_has_price() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqNewTrade::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline double ReqNewTrade::price() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.ReqNewTrade.price)
  return price_;
}
inline void ReqNewTrade::set_price(double value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.ReqNewTrade.price)
}

// required double amount = 5;
inline bool ReqNewTrade::has_amount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReqNewTrade::set_has_amount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReqNewTrade::clear_has_amount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReqNewTrade::clear_amount() {
  amount_ = 0;
  clear_has_amount();
}
inline double ReqNewTrade::amount() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.ReqNewTrade.amount)
  return amount_;
}
inline void ReqNewTrade::set_amount(double value) {
  set_has_amount();
  amount_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.ReqNewTrade.amount)
}

// -------------------------------------------------------------------

// RespNewTrade

// required int64 error_code = 1;
inline bool RespNewTrade::has_error_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RespNewTrade::set_has_error_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RespNewTrade::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RespNewTrade::clear_error_code() {
  error_code_ = GOOGLE_LONGLONG(0);
  clear_has_error_code();
}
inline ::google::protobuf::int64 RespNewTrade::error_code() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.RespNewTrade.error_code)
  return error_code_;
}
inline void RespNewTrade::set_error_code(::google::protobuf::int64 value) {
  set_has_error_code();
  error_code_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.RespNewTrade.error_code)
}

// optional int64 order_id = 2;
inline bool RespNewTrade::has_order_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RespNewTrade::set_has_order_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RespNewTrade::clear_has_order_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RespNewTrade::clear_order_id() {
  order_id_ = GOOGLE_LONGLONG(0);
  clear_has_order_id();
}
inline ::google::protobuf::int64 RespNewTrade::order_id() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.RespNewTrade.order_id)
  return order_id_;
}
inline void RespNewTrade::set_order_id(::google::protobuf::int64 value) {
  set_has_order_id();
  order_id_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.RespNewTrade.order_id)
}

// -------------------------------------------------------------------

// ReqCancelTrade

// required .digitalcurrency.Exchange exchange = 1;
inline bool ReqCancelTrade::has_exchange() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqCancelTrade::set_has_exchange() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqCancelTrade::clear_has_exchange() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqCancelTrade::clear_exchange() {
  exchange_ = 0;
  clear_has_exchange();
}
inline ::digitalcurrency::Exchange ReqCancelTrade::exchange() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.ReqCancelTrade.exchange)
  return static_cast< ::digitalcurrency::Exchange >(exchange_);
}
inline void ReqCancelTrade::set_exchange(::digitalcurrency::Exchange value) {
  assert(::digitalcurrency::Exchange_IsValid(value));
  set_has_exchange();
  exchange_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.ReqCancelTrade.exchange)
}

// required int64 order_id = 2;
inline bool ReqCancelTrade::has_order_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqCancelTrade::set_has_order_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqCancelTrade::clear_has_order_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqCancelTrade::clear_order_id() {
  order_id_ = GOOGLE_LONGLONG(0);
  clear_has_order_id();
}
inline ::google::protobuf::int64 ReqCancelTrade::order_id() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.ReqCancelTrade.order_id)
  return order_id_;
}
inline void ReqCancelTrade::set_order_id(::google::protobuf::int64 value) {
  set_has_order_id();
  order_id_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.ReqCancelTrade.order_id)
}

// -------------------------------------------------------------------

// RespCancelTrade

// required int64 error_code = 1;
inline bool RespCancelTrade::has_error_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RespCancelTrade::set_has_error_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RespCancelTrade::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RespCancelTrade::clear_error_code() {
  error_code_ = GOOGLE_LONGLONG(0);
  clear_has_error_code();
}
inline ::google::protobuf::int64 RespCancelTrade::error_code() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.RespCancelTrade.error_code)
  return error_code_;
}
inline void RespCancelTrade::set_error_code(::google::protobuf::int64 value) {
  set_has_error_code();
  error_code_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.RespCancelTrade.error_code)
}

// -------------------------------------------------------------------

// ReqOrderInfo

// required .digitalcurrency.Exchange exchange = 1;
inline bool ReqOrderInfo::has_exchange() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqOrderInfo::set_has_exchange() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqOrderInfo::clear_has_exchange() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqOrderInfo::clear_exchange() {
  exchange_ = 0;
  clear_has_exchange();
}
inline ::digitalcurrency::Exchange ReqOrderInfo::exchange() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.ReqOrderInfo.exchange)
  return static_cast< ::digitalcurrency::Exchange >(exchange_);
}
inline void ReqOrderInfo::set_exchange(::digitalcurrency::Exchange value) {
  assert(::digitalcurrency::Exchange_IsValid(value));
  set_has_exchange();
  exchange_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.ReqOrderInfo.exchange)
}

// optional int64 order_id = 2;
inline bool ReqOrderInfo::has_order_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqOrderInfo::set_has_order_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqOrderInfo::clear_has_order_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqOrderInfo::clear_order_id() {
  order_id_ = GOOGLE_LONGLONG(0);
  clear_has_order_id();
}
inline ::google::protobuf::int64 ReqOrderInfo::order_id() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.ReqOrderInfo.order_id)
  return order_id_;
}
inline void ReqOrderInfo::set_order_id(::google::protobuf::int64 value) {
  set_has_order_id();
  order_id_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.ReqOrderInfo.order_id)
}

// -------------------------------------------------------------------

// RespOrderInfo

// required int64 error_code = 1;
inline bool RespOrderInfo::has_error_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RespOrderInfo::set_has_error_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RespOrderInfo::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RespOrderInfo::clear_error_code() {
  error_code_ = GOOGLE_LONGLONG(0);
  clear_has_error_code();
}
inline ::google::protobuf::int64 RespOrderInfo::error_code() const {
  // @@protoc_insertion_point(field_get:digitalcurrency.RespOrderInfo.error_code)
  return error_code_;
}
inline void RespOrderInfo::set_error_code(::google::protobuf::int64 value) {
  set_has_error_code();
  error_code_ = value;
  // @@protoc_insertion_point(field_set:digitalcurrency.RespOrderInfo.error_code)
}

// repeated .digitalcurrency.OrderData order_data = 2;
inline int RespOrderInfo::order_data_size() const {
  return order_data_.size();
}
inline void RespOrderInfo::clear_order_data() {
  order_data_.Clear();
}
inline ::digitalcurrency::OrderData* RespOrderInfo::mutable_order_data(int index) {
  // @@protoc_insertion_point(field_mutable:digitalcurrency.RespOrderInfo.order_data)
  return order_data_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::digitalcurrency::OrderData >*
RespOrderInfo::mutable_order_data() {
  // @@protoc_insertion_point(field_mutable_list:digitalcurrency.RespOrderInfo.order_data)
  return &order_data_;
}
inline const ::digitalcurrency::OrderData& RespOrderInfo::order_data(int index) const {
  // @@protoc_insertion_point(field_get:digitalcurrency.RespOrderInfo.order_data)
  return order_data_.Get(index);
}
inline ::digitalcurrency::OrderData* RespOrderInfo::add_order_data() {
  // @@protoc_insertion_point(field_add:digitalcurrency.RespOrderInfo.order_data)
  return order_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::digitalcurrency::OrderData >&
RespOrderInfo::order_data() const {
  // @@protoc_insertion_point(field_list:digitalcurrency.RespOrderInfo.order_data)
  return order_data_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace digitalcurrency

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::digitalcurrency::MessgeTypeID> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::digitalcurrency::MessgeTypeID>() {
  return ::digitalcurrency::MessgeTypeID_descriptor();
}
template <> struct is_proto_enum< ::digitalcurrency::TradingPair> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::digitalcurrency::TradingPair>() {
  return ::digitalcurrency::TradingPair_descriptor();
}
template <> struct is_proto_enum< ::digitalcurrency::Exchange> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::digitalcurrency::Exchange>() {
  return ::digitalcurrency::Exchange_descriptor();
}
template <> struct is_proto_enum< ::digitalcurrency::KlineInterval> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::digitalcurrency::KlineInterval>() {
  return ::digitalcurrency::KlineInterval_descriptor();
}
template <> struct is_proto_enum< ::digitalcurrency::TradeType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::digitalcurrency::TradeType>() {
  return ::digitalcurrency::TradeType_descriptor();
}
template <> struct is_proto_enum< ::digitalcurrency::OrderStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::digitalcurrency::OrderStatus>() {
  return ::digitalcurrency::OrderStatus_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_protos_2fcoin_5fquote_2eproto
