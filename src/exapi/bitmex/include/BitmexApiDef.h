/* $Id: 2018-09-19 00:23:37 $
 * 
 * DO NOT MODIFY! This file is auto-generated by xJSON's swagger2c tool.
 *
 * Copyright (c) 2014-2018 Zerone.IO. All rights reserved.
 *
 */

#ifndef __BITMEXAPIDEF_H__
#define __BITMEXAPIDEF_H__

/*----------------------- Definitions ---------------------*/

struct Announcement;
struct Error;
struct APIKey;
struct Chat;
struct ChatChannel;
struct ConnectedUsers;
struct Execution;
struct Funding;
struct Instrument;
struct InstrumentInterval;
struct IndexComposite;
struct Insurance;
struct Leaderboard;
struct Liquidation;
struct Notification;
struct Order;
struct OrderBookL2;
struct Position;
struct Quote;
struct Settlement;
struct Stats;
struct StatsHistory;
struct StatsUSD;
struct Trade;
struct TradeBin;
struct Wallet;
struct Transaction;
struct AccessToken;
struct Affiliate;
struct User;
struct UserCommission;
struct Margin;
struct UserPreferences;

/**
 * Announcement
 * Public Announcements
 */
struct Announcement {
    long          id;                        ///< 
    char *  link;                      ///< 
    const char *  title;                     ///< 
    const char *  content;                   ///< 
    time_t        date;                      ///< 

    size_t       _bufsiz;                    ///< internal buffer size
    const char   _buf[0];                    ///< internal buffer contains strings
};

/**
 * Error
 */
struct Error {
    void *        error;                     ///< 

    size_t       _bufsiz;                    ///< internal buffer size
    const char   _buf[0];                    ///< internal buffer contains strings
};

/**
 * APIKey
 * Persistent API Keys for Developers
 */
struct APIKey {
    const char *  id;                        ///<  maxlength: 24
    const char *  secret;                    ///<  maxlength: 48
    const char *  name;                      ///<  maxlength: 64
    long          nonce;                     ///<  default: 0
    const char *  cidr;                      ///<  maxlength: 18
    json_t        permissions;               ///<  default: []
    bool          enabled;                   ///<  default: false
    long          userId;                    ///< 
    time_t        created;                   ///< 

    size_t       _bufsiz;                    ///< internal buffer size
    const char   _buf[0];                    ///< internal buffer contains strings
};

/**
 * Chat
 * Trollbox Data
 */
struct Chat {
    long          id;                        ///< 
    time_t        date;                      ///< 
    const char *  user;                      ///< 
    const char *  message;                   ///< 
    const char *  html;                      ///< 
    bool          fromBot;                   ///<  default: false
    double        channelID;                 ///< 

    size_t       _bufsiz;                    ///< internal buffer size
    const char   _buf[0];                    ///< internal buffer contains strings
};

/**
 * ChatChannel
 */
struct ChatChannel {
    long          id;                        ///< 
    const char *  name;                      ///< 

    size_t       _bufsiz;                    ///< internal buffer size
    const char   _buf[0];                    ///< internal buffer contains strings
};

/**
 * ConnectedUsers
 */
struct ConnectedUsers {
    long          users;                     ///< 
    long          bots;                      ///< 

    size_t       _bufsiz;                    ///< internal buffer size
    const char   _buf[0];                    ///< internal buffer contains strings
};

/**
 * Execution
 * Raw Order and Balance Data
 */
struct Execution {
    const char *  execID;                    ///< 
    const char *  orderID;                   ///< 
    const char *  clOrdID;                   ///< 
    const char *  clOrdLinkID;               ///< 
    long          account;                   ///< 
    const char *  symbol;                    ///< 
    const char *  side;                      ///< 
    long          lastQty;                   ///< 
    double        lastPx;                    ///< 
    double        underlyingLastPx;          ///< 
    const char *  lastMkt;                   ///< 
    const char *  lastLiquidityInd;          ///< 
    double        simpleOrderQty;            ///< 
    long          orderQty;                  ///< 
    double        price;                     ///< 
    long          displayQty;                ///< 
    double        stopPx;                    ///< 
    double        pegOffsetValue;            ///< 
    const char *  pegPriceType;              ///< 
    const char *  currency;                  ///< 
    const char *  settlCurrency;             ///< 
    const char *  execType;                  ///< 
    const char *  ordType;                   ///< 
    const char *  timeInForce;               ///< 
    const char *  execInst;                  ///< 
    const char *  contingencyType;           ///< 
    const char *  exDestination;             ///< 
    const char *  ordStatus;                 ///< 
    const char *  triggered;                 ///< 
    bool          workingIndicator;          ///< 
    const char *  ordRejReason;              ///< 
    double        simpleLeavesQty;           ///< 
    long          leavesQty;                 ///< 
    double        simpleCumQty;              ///< 
    long          cumQty;                    ///< 
    double        avgPx;                     ///< 
    double        commission;                ///< 
    const char *  tradePublishIndicator;     ///< 
    const char *  multiLegReportingType;     ///< 
    const char *  text;                      ///< 
    const char *  trdMatchID;                ///< 
    long          execCost;                  ///< 
    long          execComm;                  ///< 
    double        homeNotional;              ///< 
    double        foreignNotional;           ///< 
    time_t        transactTime;              ///< 
    time_t        timestamp;                 ///< 

    size_t       _bufsiz;                    ///< internal buffer size
    const char   _buf[0];                    ///< internal buffer contains strings
};

/**
 * Funding
 * Swap Funding History
 */
struct Funding {
    time_t        timestamp;                 ///< 
    const char *  symbol;                    ///< 
    time_t        fundingInterval;           ///< 
    double        fundingRate;               ///< 
    double        fundingRateDaily;          ///< 

    size_t       _bufsiz;                    ///< internal buffer size
    const char   _buf[0];                    ///< internal buffer contains strings
};

/**
 * Instrument
 * Tradeable Contracts, Indices, and History
 */
struct Instrument {
    const char *  symbol;                    ///< 
    const char *  rootSymbol;                ///< 
    const char *  state;                     ///< 
    const char *  typ;                       ///< 
    time_t        listing;                   ///< 
    time_t        front;                     ///< 
    time_t        expiry;                    ///< 
    time_t        settle;                    ///< 
    time_t        relistInterval;            ///< 
    const char *  inverseLeg;                ///< 
    const char *  sellLeg;                   ///< 
    const char *  buyLeg;                    ///< 
    double        optionStrikePcnt;          ///< 
    double        optionStrikeRound;         ///< 
    double        optionStrikePrice;         ///< 
    double        optionMultiplier;          ///< 
    const char *  positionCurrency;          ///< 
    const char *  underlying;                ///< 
    const char *  quoteCurrency;             ///< 
    const char *  underlyingSymbol;          ///< 
    const char *  reference;                 ///< 
    const char *  referenceSymbol;           ///< 
    time_t        calcInterval;              ///< 
    time_t        publishInterval;           ///< 
    time_t        publishTime;               ///< 
    long          maxOrderQty;               ///< 
    double        maxPrice;                  ///< 
    long          lotSize;                   ///< 
    double        tickSize;                  ///< 
    long          multiplier;                ///< 
    const char *  settlCurrency;             ///< 
    long          underlyingToPositionMultiplier;///< 
    long          underlyingToSettleMultiplier;///< 
    long          quoteToSettleMultiplier;   ///< 
    bool          isQuanto;                  ///< 
    bool          isInverse;                 ///< 
    double        initMargin;                ///< 
    double        maintMargin;               ///< 
    long          riskLimit;                 ///< 
    long          riskStep;                  ///< 
    double        limit;                     ///< 
    bool          capped;                    ///< 
    bool          taxed;                     ///< 
    bool          deleverage;                ///< 
    double        makerFee;                  ///< 
    double        takerFee;                  ///< 
    double        settlementFee;             ///< 
    double        insuranceFee;              ///< 
    const char *  fundingBaseSymbol;         ///< 
    const char *  fundingQuoteSymbol;        ///< 
    const char *  fundingPremiumSymbol;      ///< 
    time_t        fundingTimestamp;          ///< 
    time_t        fundingInterval;           ///< 
    double        fundingRate;               ///< 
    double        indicativeFundingRate;     ///< 
    time_t        rebalanceTimestamp;        ///< 
    time_t        rebalanceInterval;         ///< 
    time_t        openingTimestamp;          ///< 
    time_t        closingTimestamp;          ///< 
    time_t        sessionInterval;           ///< 
    double        prevClosePrice;            ///< 
    double        limitDownPrice;            ///< 
    double        limitUpPrice;              ///< 
    double        bankruptLimitDownPrice;    ///< 
    double        bankruptLimitUpPrice;      ///< 
    long          prevTotalVolume;           ///< 
    long          totalVolume;               ///< 
    long          volume;                    ///< 
    long          volume24h;                 ///< 
    long          prevTotalTurnover;         ///< 
    long          totalTurnover;             ///< 
    long          turnover;                  ///< 
    long          turnover24h;               ///< 
    double        prevPrice24h;              ///< 
    double        vwap;                      ///< 
    double        highPrice;                 ///< 
    double        lowPrice;                  ///< 
    double        lastPrice;                 ///< 
    double        lastPriceProtected;        ///< 
    const char *  lastTickDirection;         ///< 
    double        lastChangePcnt;            ///< 
    double        bidPrice;                  ///< 
    double        midPrice;                  ///< 
    double        askPrice;                  ///< 
    double        impactBidPrice;            ///< 
    double        impactMidPrice;            ///< 
    double        impactAskPrice;            ///< 
    bool          hasLiquidity;              ///< 
    long          openInterest;              ///< 
    long          openValue;                 ///< 
    const char *  fairMethod;                ///< 
    double        fairBasisRate;             ///< 
    double        fairBasis;                 ///< 
    double        fairPrice;                 ///< 
    const char *  markMethod;                ///< 
    double        markPrice;                 ///< 
    double        indicativeTaxRate;         ///< 
    double        indicativeSettlePrice;     ///< 
    double        optionUnderlyingPrice;     ///< 
    double        settledPrice;              ///< 
    time_t        timestamp;                 ///< 

    size_t       _bufsiz;                    ///< internal buffer size
    const char   _buf[0];                    ///< internal buffer contains strings
};

/**
 * InstrumentInterval
 */
struct InstrumentInterval {
    const char ** intervals;                 ///< 
    const char ** symbols;                   ///< 

    size_t       _bufsiz;                    ///< internal buffer size
    const char   _buf[0];                    ///< internal buffer contains strings
};

/**
 * IndexComposite
 */
struct IndexComposite {
    time_t        timestamp;                 ///< 
    const char *  symbol;                    ///< 
    const char *  indexSymbol;               ///< 
    const char *  reference;                 ///< 
    double        lastPrice;                 ///< 
    double        weight;                    ///< 
    time_t        logged;                    ///< 

    size_t       _bufsiz;                    ///< internal buffer size
    const char   _buf[0];                    ///< internal buffer contains strings
};

/**
 * Insurance
 * Insurance Fund Data
 */
struct Insurance {
    const char *  currency;                  ///< 
    time_t        timestamp;                 ///< 
    long          walletBalance;             ///< 

    size_t       _bufsiz;                    ///< internal buffer size
    const char   _buf[0];                    ///< internal buffer contains strings
};

/**
 * Leaderboard
 * Information on Top Users
 */
struct Leaderboard {
    const char *  name;                      ///< 
    bool          isRealName;                ///< 
    double        profit;                    ///< 

    size_t       _bufsiz;                    ///< internal buffer size
    const char   _buf[0];                    ///< internal buffer contains strings
};

/**
 * Liquidation
 * Active Liquidations
 */
struct Liquidation {
    const char *  orderID;                   ///< 
    const char *  symbol;                    ///< 
    const char *  side;                      ///< 
    double        price;                     ///< 
    long          leavesQty;                 ///< 

    size_t       _bufsiz;                    ///< internal buffer size
    const char   _buf[0];                    ///< internal buffer contains strings
};

/**
 * Notification
 * Account Notifications
 */
struct Notification {
    long          id;                        ///< 
    time_t        date;                      ///< 
    const char *  title;                     ///< 
    const char *  body;                      ///< 
    long          ttl;                       ///< 
    const char *  type;                      ///< 
    bool          closable;                  ///<  default: true
    bool          persist;                   ///<  default: true
    bool          waitForVisibility;         ///<  default: true
    const char *  sound;                     ///< 

    size_t       _bufsiz;                    ///< internal buffer size
    const char   _buf[0];                    ///< internal buffer contains strings
};

/**
 * Order
 * Placement, Cancellation, Amending, and History
 */
struct Order {
    const char *  orderID;                   ///< 
    const char *  clOrdID;                   ///< 
    const char *  clOrdLinkID;               ///< 
    long          account;                   ///< 
    const char *  symbol;                    ///< 
    const char *  side;                      ///< 
    double        simpleOrderQty;            ///< 
    long          orderQty;                  ///< 
    double        price;                     ///< 
    long          displayQty;                ///< 
    double        stopPx;                    ///< 
    double        pegOffsetValue;            ///< 
    const char *  pegPriceType;              ///< 
    const char *  currency;                  ///< 
    const char *  settlCurrency;             ///< 
    const char *  ordType;                   ///< 
    const char *  timeInForce;               ///< 
    const char *  execInst;                  ///< 
    const char *  contingencyType;           ///< 
    const char *  exDestination;             ///< 
    const char *  ordStatus;                 ///< 
    const char *  triggered;                 ///< 
    bool          workingIndicator;          ///< 
    const char *  ordRejReason;              ///< 
    double        simpleLeavesQty;           ///< 
    long          leavesQty;                 ///< 
    double        simpleCumQty;              ///< 
    long          cumQty;                    ///< 
    double        avgPx;                     ///< 
    const char *  multiLegReportingType;     ///< 
    const char *  text;                      ///< 
    time_t        transactTime;              ///< 
    time_t        timestamp;                 ///< 

    size_t       _bufsiz;                    ///< internal buffer size
    const char   _buf[0];                    ///< internal buffer contains strings
};

/**
 * OrderBookL2
 */
struct OrderBookL2 {
    const char *  symbol;                    ///< 
    long          id;                        ///< 
    const char *  side;                      ///< 
    long          size;                      ///< 
    double        price;                     ///< 

    size_t       _bufsiz;                    ///< internal buffer size
    const char   _buf[0];                    ///< internal buffer contains strings
};

/**
 * Position
 * Summary of Open and Closed Positions
 */
struct Position {
    long          account;                   ///<  default: 0
    const char *  symbol;                    ///< 
    const char *  currency;                  ///< 
    const char *  underlying;                ///< 
    const char *  quoteCurrency;             ///< 
    double        commission;                ///<  default: 0
    double        initMarginReq;             ///<  default: 0
    double        maintMarginReq;            ///<  default: 0
    long          riskLimit;                 ///<  default: 0
    double        leverage;                  ///<  default: 0
    bool          crossMargin;               ///< 
    double        deleveragePercentile;      ///<  default: 0
    long          rebalancedPnl;             ///<  default: 0
    long          prevRealisedPnl;           ///<  default: 0
    long          prevUnrealisedPnl;         ///<  default: 0
    double        prevClosePrice;            ///<  default: 0
    time_t        openingTimestamp;          ///< 
    long          openingQty;                ///<  default: 0
    long          openingCost;               ///<  default: 0
    long          openingComm;               ///<  default: 0
    long          openOrderBuyQty;           ///<  default: 0
    long          openOrderBuyCost;          ///<  default: 0
    long          openOrderBuyPremium;       ///<  default: 0
    long          openOrderSellQty;          ///<  default: 0
    long          openOrderSellCost;         ///<  default: 0
    long          openOrderSellPremium;      ///<  default: 0
    long          execBuyQty;                ///<  default: 0
    long          execBuyCost;               ///<  default: 0
    long          execSellQty;               ///<  default: 0
    long          execSellCost;              ///<  default: 0
    long          execQty;                   ///<  default: 0
    long          execCost;                  ///<  default: 0
    long          execComm;                  ///<  default: 0
    time_t        currentTimestamp;          ///< 
    long          currentQty;                ///<  default: 0
    long          currentCost;               ///<  default: 0
    long          currentComm;               ///<  default: 0
    long          realisedCost;              ///<  default: 0
    long          unrealisedCost;            ///<  default: 0
    long          grossOpenCost;             ///<  default: 0
    long          grossOpenPremium;          ///<  default: 0
    long          grossExecCost;             ///<  default: 0
    bool          isOpen;                    ///< 
    double        markPrice;                 ///<  default: 0
    long          markValue;                 ///<  default: 0
    long          riskValue;                 ///<  default: 0
    double        homeNotional;              ///<  default: 0
    double        foreignNotional;           ///<  default: 0
    const char *  posState;                  ///< 
    long          posCost;                   ///<  default: 0
    long          posCost2;                  ///<  default: 0
    long          posCross;                  ///<  default: 0
    long          posInit;                   ///<  default: 0
    long          posComm;                   ///<  default: 0
    long          posLoss;                   ///<  default: 0
    long          posMargin;                 ///<  default: 0
    long          posMaint;                  ///<  default: 0
    long          posAllowance;              ///<  default: 0
    long          taxableMargin;             ///<  default: 0
    long          initMargin;                ///<  default: 0
    long          maintMargin;               ///<  default: 0
    long          sessionMargin;             ///<  default: 0
    long          targetExcessMargin;        ///<  default: 0
    long          varMargin;                 ///<  default: 0
    long          realisedGrossPnl;          ///<  default: 0
    long          realisedTax;               ///<  default: 0
    long          realisedPnl;               ///<  default: 0
    long          unrealisedGrossPnl;        ///<  default: 0
    long          longBankrupt;              ///<  default: 0
    long          shortBankrupt;             ///<  default: 0
    long          taxBase;                   ///<  default: 0
    double        indicativeTaxRate;         ///<  default: 0
    long          indicativeTax;             ///<  default: 0
    long          unrealisedTax;             ///<  default: 0
    long          unrealisedPnl;             ///<  default: 0
    double        unrealisedPnlPcnt;         ///<  default: 0
    double        unrealisedRoePcnt;         ///<  default: 0
    double        simpleQty;                 ///<  default: 0
    double        simpleCost;                ///<  default: 0
    double        simpleValue;               ///<  default: 0
    double        simplePnl;                 ///<  default: 0
    double        simplePnlPcnt;             ///<  default: 0
    double        avgCostPrice;              ///<  default: 0
    double        avgEntryPrice;             ///<  default: 0
    double        breakEvenPrice;            ///<  default: 0
    double        marginCallPrice;           ///<  default: 0
    double        liquidationPrice;          ///<  default: 0
    double        bankruptPrice;             ///<  default: 0
    time_t        timestamp;                 ///< 
    double        lastPrice;                 ///<  default: 0
    long          lastValue;                 ///<  default: 0

    size_t       _bufsiz;                    ///< internal buffer size
    const char   _buf[0];                    ///< internal buffer contains strings
};

/**
 * Quote
 * Best Bid/Offer Snapshots & Historical Bins
 */
struct Quote {
    time_t        timestamp;                 ///< 
    const char *  symbol;                    ///< 
    long          bidSize;                   ///< 
    double        bidPrice;                  ///< 
    double        askPrice;                  ///< 
    long          askSize;                   ///< 

    size_t       _bufsiz;                    ///< internal buffer size
    const char   _buf[0];                    ///< internal buffer contains strings
};

/**
 * Settlement
 * Historical Settlement Data
 */
struct Settlement {
    time_t        timestamp;                 ///< 
    const char *  symbol;                    ///< 
    const char *  settlementType;            ///< 
    double        settledPrice;              ///< 
    double        optionStrikePrice;         ///< 
    double        optionUnderlyingPrice;     ///< 
    long          bankrupt;                  ///< 
    long          taxBase;                   ///< 
    double        taxRate;                   ///< 

    size_t       _bufsiz;                    ///< internal buffer size
    const char   _buf[0];                    ///< internal buffer contains strings
};

/**
 * Stats
 * Exchange Statistics
 */
struct Stats {
    const char *  rootSymbol;                ///< 
    const char *  currency;                  ///< 
    long          volume24h;                 ///< 
    long          turnover24h;               ///< 
    long          openInterest;              ///< 
    long          openValue;                 ///< 

    size_t       _bufsiz;                    ///< internal buffer size
    const char   _buf[0];                    ///< internal buffer contains strings
};

/**
 * StatsHistory
 */
struct StatsHistory {
    time_t        date;                      ///< 
    const char *  rootSymbol;                ///< 
    const char *  currency;                  ///< 
    long          volume;                    ///< 
    long          turnover;                  ///< 

    size_t       _bufsiz;                    ///< internal buffer size
    const char   _buf[0];                    ///< internal buffer contains strings
};

/**
 * StatsUSD
 */
struct StatsUSD {
    const char *  rootSymbol;                ///< 
    const char *  currency;                  ///< 
    long          turnover24h;               ///< 
    long          turnover30d;               ///< 
    long          turnover365d;              ///< 
    long          turnover;                  ///< 

    size_t       _bufsiz;                    ///< internal buffer size
    const char   _buf[0];                    ///< internal buffer contains strings
};

/**
 * Trade
 * Individual & Bucketed Trades
 */
struct Trade {
    time_t        timestamp;                 ///< 
    const char *  symbol;                    ///< 
    const char *  side;                      ///< 
    long          size;                      ///< 
    double        price;                     ///< 
    const char *  tickDirection;             ///< 
    const char *  trdMatchID;                ///< 
    long          grossValue;                ///< 
    double        homeNotional;              ///< 
    double        foreignNotional;           ///< 

    size_t       _bufsiz;                    ///< internal buffer size
    const char   _buf[0];                    ///< internal buffer contains strings
};

/**
 * TradeBin
 */
struct TradeBin {
    time_t        timestamp;                 ///< 
    const char *  symbol;                    ///< 
    double        open;                      ///< 
    double        high;                      ///< 
    double        low;                       ///< 
    double        close;                     ///< 
    long          trades;                    ///< 
    long          volume;                    ///< 
    double        vwap;                      ///< 
    long          lastSize;                  ///< 
    long          turnover;                  ///< 
    double        homeNotional;              ///< 
    double        foreignNotional;           ///< 

    size_t       _bufsiz;                    ///< internal buffer size
    const char   _buf[0];                    ///< internal buffer contains strings
};

/**
 * Wallet
 */
struct Wallet {
    long          account;                   ///< 
    const char *  currency;                  ///< 
    long          prevDeposited;             ///< 
    long          prevWithdrawn;             ///< 
    long          prevTransferIn;            ///< 
    long          prevTransferOut;           ///< 
    long          prevAmount;                ///< 
    time_t        prevTimestamp;             ///< 
    long          deltaDeposited;            ///< 
    long          deltaWithdrawn;            ///< 
    long          deltaTransferIn;           ///< 
    long          deltaTransferOut;          ///< 
    long          deltaAmount;               ///< 
    long          deposited;                 ///< 
    long          withdrawn;                 ///< 
    long          transferIn;                ///< 
    long          transferOut;               ///< 
    long          amount;                    ///< 
    long          pendingCredit;             ///< 
    long          pendingDebit;              ///< 
    long          confirmedDebit;            ///< 
    time_t        timestamp;                 ///< 
    const char *  addr;                      ///< 
    const char *  script;                    ///< 
    const char ** withdrawalLock;            ///< 

    size_t       _bufsiz;                    ///< internal buffer size
    const char   _buf[0];                    ///< internal buffer contains strings
};

/**
 * Transaction
 */
struct Transaction {
    const char *  transactID;                ///< 
    long          account;                   ///< 
    const char *  currency;                  ///< 
    const char *  transactType;              ///< 
    long          amount;                    ///< 
    long          fee;                       ///< 
    const char *  transactStatus;            ///< 
    const char *  address;                   ///< 
    const char *  tx;                        ///< 
    const char *  text;                      ///< 
    time_t        transactTime;              ///< 
    time_t        timestamp;                 ///< 

    size_t       _bufsiz;                    ///< internal buffer size
    const char   _buf[0];                    ///< internal buffer contains strings
};

/**
 * AccessToken
 */
struct AccessToken {
    const char *  id;                        ///< 
    double        ttl;                       ///< time to live in seconds (2 weeks by default) default: 1209600
    time_t        created;                   ///< 
    double        userId;                    ///< 

    size_t       _bufsiz;                    ///< internal buffer size
    const char   _buf[0];                    ///< internal buffer contains strings
};

/**
 * Affiliate
 */
struct Affiliate {
    long          account;                   ///< 
    const char *  currency;                  ///< 
    long          prevPayout;                ///< 
    long          prevTurnover;              ///< 
    long          prevComm;                  ///< 
    time_t        prevTimestamp;             ///< 
    long          execTurnover;              ///< 
    long          execComm;                  ///< 
    long          totalReferrals;            ///< 
    long          totalTurnover;             ///< 
    long          totalComm;                 ///< 
    double        payoutPcnt;                ///< 
    long          pendingPayout;             ///< 
    time_t        timestamp;                 ///< 
    double        referrerAccount;           ///< 

    size_t       _bufsiz;                    ///< internal buffer size
    const char   _buf[0];                    ///< internal buffer contains strings
};

/**
 * User
 * Account Operations
 */
struct User {
    long          id;                        ///< 
    long          ownerId;                   ///< 
    const char *  firstname;                 ///< 
    const char *  lastname;                  ///< 
    const char *  username;                  ///< 
    const char *  email;                     ///< 
    const char *  phone;                     ///< 
    time_t        created;                   ///< 
    time_t        lastUpdated;               ///< 
    UserPreferences* preferences;            ///<  default: { }
    const char *  TFAEnabled;                ///< 
    const char *  affiliateID;               ///<  maxlength: 6
    const char *  pgpPubKey;                 ///<  maxlength: 16384
    const char *  country;                   ///<  maxlength: 3
    const char *  geoipCountry;              ///<  maxlength: 2
    const char *  geoipRegion;               ///<  maxlength: 2
    const char *  typ;                       ///< 

    size_t       _bufsiz;                    ///< internal buffer size
    const char   _buf[0];                    ///< internal buffer contains strings
};

/**
 * UserCommission
 */
struct UserCommission {
    double        makerFee;                  ///< 
    double        takerFee;                  ///< 
    double        settlementFee;             ///< 
    double        maxFee;                    ///< 

    size_t       _bufsiz;                    ///< internal buffer size
    const char   _buf[0];                    ///< internal buffer contains strings
};

/**
 * Margin
 */
struct Margin {
    long          account;                   ///<  default: 0
    const char *  currency;                  ///< 
    long          riskLimit;                 ///<  default: 0
    const char *  prevState;                 ///< 
    const char *  state;                     ///< 
    const char *  action;                    ///< 
    long          amount;                    ///<  default: 0
    long          pendingCredit;             ///<  default: 0
    long          pendingDebit;              ///<  default: 0
    long          confirmedDebit;            ///<  default: 0
    long          prevRealisedPnl;           ///<  default: 0
    long          prevUnrealisedPnl;         ///<  default: 0
    long          grossComm;                 ///<  default: 0
    long          grossOpenCost;             ///<  default: 0
    long          grossOpenPremium;          ///<  default: 0
    long          grossExecCost;             ///<  default: 0
    long          grossMarkValue;            ///<  default: 0
    long          riskValue;                 ///<  default: 0
    long          taxableMargin;             ///<  default: 0
    long          initMargin;                ///<  default: 0
    long          maintMargin;               ///<  default: 0
    long          sessionMargin;             ///<  default: 0
    long          targetExcessMargin;        ///<  default: 0
    long          varMargin;                 ///<  default: 0
    long          realisedPnl;               ///<  default: 0
    long          unrealisedPnl;             ///<  default: 0
    long          indicativeTax;             ///<  default: 0
    long          unrealisedProfit;          ///<  default: 0
    long          syntheticMargin;           ///<  default: 0
    long          walletBalance;             ///<  default: 0
    long          marginBalance;             ///<  default: 0
    double        marginBalancePcnt;         ///<  default: 0
    double        marginLeverage;            ///<  default: 0
    double        marginUsedPcnt;            ///<  default: 0
    long          excessMargin;              ///<  default: 0
    double        excessMarginPcnt;          ///<  default: 0
    long          availableMargin;           ///<  default: 0
    long          withdrawableMargin;        ///<  default: 0
    time_t        timestamp;                 ///< 
    long          grossLastValue;            ///<  default: 0
    double        commission;                ///<  default: 0

    size_t       _bufsiz;                    ///< internal buffer size
    const char   _buf[0];                    ///< internal buffer contains strings
};

/**
 * UserPreferences
 */
struct UserPreferences {
    bool          alertOnLiquidations;       ///< 
    bool          animationsEnabled;         ///< 
    time_t        announcementsLastSeen;     ///< 
    double        chatChannelID;             ///< 
    const char *  colorTheme;                ///< 
    const char *  currency;                  ///< 
    bool          debug;                     ///< 
    const char ** disableEmails;             ///< 
    const char ** hideConfirmDialogs;        ///< 
    bool          hideConnectionModal;       ///< 
    bool          hideFromLeaderboard;       ///<  default: false
    bool          hideNameFromLeaderboard;   ///<  default: true
    const char ** hideNotifications;         ///< 
    const char *  locale;                    ///<  default: "en-US"
    const char ** msgsSeen;                  ///< 
    void *        orderBookBinning;          ///< 
    const char *  orderBookType;             ///< 
    bool          orderClearImmediate;       ///<  default: false
    bool          orderControlsPlusMinus;    ///< 
    bool          showLocaleNumbers;         ///<  default: true
    const char ** sounds;                    ///< 
    bool          strictIPCheck;             ///<  default: false
    bool          strictTimeout;             ///<  default: true
    const char *  tickerGroup;               ///< 
    bool          tickerPinned;              ///< 
    const char *  tradeLayout;               ///< 

    size_t       _bufsiz;                    ///< internal buffer size
    const char   _buf[0];                    ///< internal buffer contains strings
};

/*--------------------- Path Parameters -------------------*/

/**
 * GET /api/v1/announcement
 * Get site announcements.
 * security: []
 */
struct AnnouncementGetParams {
    json_t        columns;                   ///< Array of column names to fetch. If omitted, will return all columns. required: false in: "query"
};

/**
 * GET /api/v1/announcement/urgent
 * Get urgent (banner) announcements.
 */


/**
 * POST /api/v1/apiKey
 * Create a new API Key.
 */
struct APIKeyNewParams {
    const char *  name;                      ///< Key name. This name is for reference only. required: false in: "formData"
    const char *  cidr;                      ///< CIDR block to restrict this key to. To restrict to a single address, append "/32", e.g. 207.39.29.22/32. Leave blank or set to 0.0.0.0/0 to allow all IPs. Only one block may be set. <a href="http://software77.net/cidr-101.html">More on CIDR blocks</a> required: false in: "formData"
    json_t        permissions;               ///< Key Permissions. All keys can read margin and position data. Additional permissions must be added. Available: ["order", "orderCancel", "withdraw"]. required: false in: "formData"
    bool          enabled;                   ///< Set to true to enable this key on creation. Otherwise, it must be explicitly enabled via /apiKey/enable. default: false required: false in: "formData"
    const char *  token;                     ///< OTP Token (YubiKey, Google Authenticator) required: false in: "formData"
};

/**
 * POST /api/v1/apiKey/disable
 * Disable an API Key.
 */
struct APIKeyDisableParams {
    const char *  apiKeyID;                  ///< API Key ID (public component). required: true in: "formData"
};

/**
 * POST /api/v1/apiKey/enable
 * Enable an API Key.
 */
struct APIKeyEnableParams {
    const char *  apiKeyID;                  ///< API Key ID (public component). required: true in: "formData"
};

/**
 * GET /api/v1/chat
 * Get chat messages.
 * security: []
 */
struct ChatGetParams {
    long          count;                     ///< Number of results to fetch. default: 100 required: false in: "query"
    long          start;                     ///< Starting ID for results. default: 0 required: false in: "query"
    bool          reverse;                   ///< If true, will sort results newest first. default: true required: false in: "query"
    double        channelID;                 ///< Channel id. GET /chat/channels for ids. Leave blank for all. required: false in: "query"
};

/**
 * GET /api/v1/chat/channels
 * Get available channels.
 * security: []
 */


/**
 * GET /api/v1/chat/connected
 * Get connected users.
 * security: []
 */


/**
 * GET /api/v1/execution
 * Get all raw executions for your account.
 */
struct ExecutionGetParams {
    const char *  symbol;                    ///< Instrument symbol. Send a bare series (e.g. XBU) to get data for the nearest expiring contract in that series.  You can also send a timeframe, e.g. `XBU:monthly`. Timeframes are `daily`, `weekly`, `monthly`, `quarterly`, and `biquarterly`. required: false in: "query"
    json_t        filter;                    ///< Generic table filter. Send JSON key/value pairs, such as `{"key": "value"}`. You can key on individual fields, and do more advanced querying on timestamps. See the [Timestamp Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for more details. required: false in: "query"
    json_t        columns;                   ///< Array of column names to fetch. If omitted, will return all columns.  Note that this method will always return item keys, even when not specified, so you may receive more columns that you expect. required: false in: "query"
    long          count;                     ///< Number of results to fetch. default: 100 required: false in: "query"
    long          start;                     ///< Starting point for results. default: 0 required: false in: "query"
    bool          reverse;                   ///< If true, will sort results newest first. default: false required: false in: "query"
    time_t        startTime;                 ///< Starting date filter for results. required: false in: "query"
    time_t        endTime;                   ///< Ending date filter for results. required: false in: "query"
};

/**
 * GET /api/v1/execution/tradeHistory
 * Get all balance-affecting executions. This includes each trade, insurance charge, and settlement.
 */
struct ExecutionGetTradeHistoryParams {
    const char *  symbol;                    ///< Instrument symbol. Send a bare series (e.g. XBU) to get data for the nearest expiring contract in that series.  You can also send a timeframe, e.g. `XBU:monthly`. Timeframes are `daily`, `weekly`, `monthly`, `quarterly`, and `biquarterly`. required: false in: "query"
    json_t        filter;                    ///< Generic table filter. Send JSON key/value pairs, such as `{"key": "value"}`. You can key on individual fields, and do more advanced querying on timestamps. See the [Timestamp Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for more details. required: false in: "query"
    json_t        columns;                   ///< Array of column names to fetch. If omitted, will return all columns.  Note that this method will always return item keys, even when not specified, so you may receive more columns that you expect. required: false in: "query"
    long          count;                     ///< Number of results to fetch. default: 100 required: false in: "query"
    long          start;                     ///< Starting point for results. default: 0 required: false in: "query"
    bool          reverse;                   ///< If true, will sort results newest first. default: false required: false in: "query"
    time_t        startTime;                 ///< Starting date filter for results. required: false in: "query"
    time_t        endTime;                   ///< Ending date filter for results. required: false in: "query"
};

/**
 * GET /api/v1/funding
 * Get funding history.
 * security: []
 */
struct FundingGetParams {
    const char *  symbol;                    ///< Instrument symbol. Send a bare series (e.g. XBU) to get data for the nearest expiring contract in that series.  You can also send a timeframe, e.g. `XBU:monthly`. Timeframes are `daily`, `weekly`, `monthly`, `quarterly`, and `biquarterly`. required: false in: "query"
    json_t        filter;                    ///< Generic table filter. Send JSON key/value pairs, such as `{"key": "value"}`. You can key on individual fields, and do more advanced querying on timestamps. See the [Timestamp Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for more details. required: false in: "query"
    json_t        columns;                   ///< Array of column names to fetch. If omitted, will return all columns.  Note that this method will always return item keys, even when not specified, so you may receive more columns that you expect. required: false in: "query"
    long          count;                     ///< Number of results to fetch. default: 100 required: false in: "query"
    long          start;                     ///< Starting point for results. default: 0 required: false in: "query"
    bool          reverse;                   ///< If true, will sort results newest first. default: false required: false in: "query"
    time_t        startTime;                 ///< Starting date filter for results. required: false in: "query"
    time_t        endTime;                   ///< Ending date filter for results. required: false in: "query"
};

/**
 * GET /api/v1/instrument
 * Get instruments.
 * security: []
 */
struct InstrumentGetParams {
    const char *  symbol;                    ///< Instrument symbol. Send a bare series (e.g. XBU) to get data for the nearest expiring contract in that series.  You can also send a timeframe, e.g. `XBU:monthly`. Timeframes are `daily`, `weekly`, `monthly`, `quarterly`, and `biquarterly`. required: false in: "query"
    json_t        filter;                    ///< Generic table filter. Send JSON key/value pairs, such as `{"key": "value"}`. You can key on individual fields, and do more advanced querying on timestamps. See the [Timestamp Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for more details. required: false in: "query"
    json_t        columns;                   ///< Array of column names to fetch. If omitted, will return all columns.  Note that this method will always return item keys, even when not specified, so you may receive more columns that you expect. required: false in: "query"
    long          count;                     ///< Number of results to fetch. default: 100 required: false in: "query"
    long          start;                     ///< Starting point for results. default: 0 required: false in: "query"
    bool          reverse;                   ///< If true, will sort results newest first. default: false required: false in: "query"
    time_t        startTime;                 ///< Starting date filter for results. required: false in: "query"
    time_t        endTime;                   ///< Ending date filter for results. required: false in: "query"
};

/**
 * GET /api/v1/instrument/active
 * Get all active instruments and instruments that have expired in <24hrs.
 * security: []
 */


/**
 * GET /api/v1/instrument/indices
 * Get all price indices.
 * security: []
 */


/**
 * GET /api/v1/instrument/activeAndIndices
 * Helper method. Gets all active instruments and all indices. This is a join of the result of /indices and /active.
 * security: []
 */


/**
 * GET /api/v1/instrument/activeIntervals
 * Return all active contract series and interval pairs.
 * security: []
 */


/**
 * GET /api/v1/instrument/compositeIndex
 * Show constituent parts of an index.
 * security: []
 */
struct InstrumentGetCompositeIndexParams {
    double        account;                   ///<  required: false in: "query"
    const char *  symbol;                    ///< The composite index symbol. default: ".XBT" required: false in: "query"
    json_t        filter;                    ///< Generic table filter. Send JSON key/value pairs, such as `{"key": "value"}`. You can key on individual fields, and do more advanced querying on timestamps. See the [Timestamp Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for more details. required: false in: "query"
    json_t        columns;                   ///< Array of column names to fetch. If omitted, will return all columns.  Note that this method will always return item keys, even when not specified, so you may receive more columns that you expect. required: false in: "query"
    long          count;                     ///< Number of results to fetch. default: 100 required: false in: "query"
    long          start;                     ///< Starting point for results. default: 0 required: false in: "query"
    bool          reverse;                   ///< If true, will sort results newest first. default: false required: false in: "query"
    time_t        startTime;                 ///< Starting date filter for results. required: false in: "query"
    time_t        endTime;                   ///< Ending date filter for results. required: false in: "query"
};

/**
 * GET /api/v1/insurance
 * Get insurance fund history.
 * security: []
 */
struct InsuranceGetParams {
    const char *  symbol;                    ///< Instrument symbol. Send a bare series (e.g. XBU) to get data for the nearest expiring contract in that series.  You can also send a timeframe, e.g. `XBU:monthly`. Timeframes are `daily`, `weekly`, `monthly`, `quarterly`, and `biquarterly`. required: false in: "query"
    json_t        filter;                    ///< Generic table filter. Send JSON key/value pairs, such as `{"key": "value"}`. You can key on individual fields, and do more advanced querying on timestamps. See the [Timestamp Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for more details. required: false in: "query"
    json_t        columns;                   ///< Array of column names to fetch. If omitted, will return all columns.  Note that this method will always return item keys, even when not specified, so you may receive more columns that you expect. required: false in: "query"
    long          count;                     ///< Number of results to fetch. default: 100 required: false in: "query"
    long          start;                     ///< Starting point for results. default: 0 required: false in: "query"
    bool          reverse;                   ///< If true, will sort results newest first. default: false required: false in: "query"
    time_t        startTime;                 ///< Starting date filter for results. required: false in: "query"
    time_t        endTime;                   ///< Ending date filter for results. required: false in: "query"
};

/**
 * GET /api/v1/leaderboard
 * Get current leaderboard.
 * security: []
 */
struct LeaderboardGetParams {
    const char *  method;                    ///< Ranking type. Options: "notional", "ROE" default: "notional" required: false in: "query"
};

/**
 * GET /api/v1/leaderboard/name
 * Get your alias on the leaderboard.
 */


/**
 * GET /api/v1/liquidation
 * Get liquidation orders.
 * security: []
 */
struct LiquidationGetParams {
    const char *  symbol;                    ///< Instrument symbol. Send a bare series (e.g. XBU) to get data for the nearest expiring contract in that series.  You can also send a timeframe, e.g. `XBU:monthly`. Timeframes are `daily`, `weekly`, `monthly`, `quarterly`, and `biquarterly`. required: false in: "query"
    json_t        filter;                    ///< Generic table filter. Send JSON key/value pairs, such as `{"key": "value"}`. You can key on individual fields, and do more advanced querying on timestamps. See the [Timestamp Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for more details. required: false in: "query"
    json_t        columns;                   ///< Array of column names to fetch. If omitted, will return all columns.  Note that this method will always return item keys, even when not specified, so you may receive more columns that you expect. required: false in: "query"
    long          count;                     ///< Number of results to fetch. default: 100 required: false in: "query"
    long          start;                     ///< Starting point for results. default: 0 required: false in: "query"
    bool          reverse;                   ///< If true, will sort results newest first. default: false required: false in: "query"
    time_t        startTime;                 ///< Starting date filter for results. required: false in: "query"
    time_t        endTime;                   ///< Ending date filter for results. required: false in: "query"
};

/**
 * GET /api/v1/notification
 * Get your current notifications.
 */


/**
 * GET /api/v1/order
 * Get your orders.
 */
struct OrderGetOrdersParams {
    const char *  symbol;                    ///< Instrument symbol. Send a bare series (e.g. XBU) to get data for the nearest expiring contract in that series.  You can also send a timeframe, e.g. `XBU:monthly`. Timeframes are `daily`, `weekly`, `monthly`, `quarterly`, and `biquarterly`. required: false in: "query"
    json_t        filter;                    ///< Generic table filter. Send JSON key/value pairs, such as `{"key": "value"}`. You can key on individual fields, and do more advanced querying on timestamps. See the [Timestamp Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for more details. required: false in: "query"
    json_t        columns;                   ///< Array of column names to fetch. If omitted, will return all columns.  Note that this method will always return item keys, even when not specified, so you may receive more columns that you expect. required: false in: "query"
    long          count;                     ///< Number of results to fetch. default: 100 required: false in: "query"
    long          start;                     ///< Starting point for results. default: 0 required: false in: "query"
    bool          reverse;                   ///< If true, will sort results newest first. default: false required: false in: "query"
    time_t        startTime;                 ///< Starting date filter for results. required: false in: "query"
    time_t        endTime;                   ///< Ending date filter for results. required: false in: "query"
};

/**
 * POST /api/v1/order/bulk
 * Create multiple new orders for the same symbol.
 */
struct OrderNewBulkParams {
    json_t        orders;                    ///< An array of orders. required: false in: "formData"
};

/**
 * POST /api/v1/order/closePosition
 * Close a position. [Deprecated, use POST /order with execInst: 'Close']
 */
struct OrderClosePositionParams {
    const char *  symbol;                    ///< Symbol of position to close. required: true in: "formData"
    double        price;                     ///< Optional limit price. required: false in: "formData"
};

/**
 * DELETE /api/v1/order/all
 * Cancels all of your orders.
 */
struct OrderCancelAllParams {
    const char *  symbol;                    ///< Optional symbol. If provided, only cancels orders for that symbol. required: false in: "formData"
    json_t        filter;                    ///< Optional filter for cancellation. Use to only cancel some orders, e.g. `{"side": "Buy"}`. required: false in: "formData"
    const char *  text;                      ///< Optional cancellation annotation. e.g. 'Spread Exceeded' required: false in: "formData"
};

/**
 * POST /api/v1/order/cancelAllAfter
 * Automatically cancel all your orders after a specified timeout.
 */
struct OrderCancelAllAfterParams {
    double        timeout;                   ///< Timeout in ms. Set to 0 to cancel this timer.  required: true in: "formData"
};

/**
 * GET /api/v1/orderBook/L2
 * Get current orderbook in vertical format.
 * security: []
 */
struct OrderBookGetL2Params {
    const char *  symbol;                    ///< Instrument symbol. Send a series (e.g. XBT) to get data for the nearest contract in that series. required: true in: "query"
    long          depth;                     ///< Orderbook depth per side. Send 0 for full depth. default: 25 required: false in: "query"
};

/**
 * GET /api/v1/position
 * Get your positions.
 */
struct PositionGetParams {
    json_t        filter;                    ///< Table filter. For example, send {"symbol": "XBTUSD"}. required: false in: "query"
    json_t        columns;                   ///< Which columns to fetch. For example, send ["columnName"]. required: false in: "query"
    long          count;                     ///< Number of rows to fetch. required: false in: "query"
};

/**
 * POST /api/v1/position/isolate
 * Enable isolated margin or cross margin per-position.
 */
struct PositionIsolateMarginParams {
    const char *  symbol;                    ///< Position symbol to isolate. required: true in: "formData"
    bool          enabled;                   ///< True for isolated margin, false for cross margin. default: true required: false in: "formData"
};

/**
 * POST /api/v1/position/riskLimit
 * Update your risk limit.
 */
struct PositionUpdateRiskLimitParams {
    const char *  symbol;                    ///< Symbol of position to update risk limit on. required: true in: "formData"
    long          riskLimit;                 ///< New Risk Limit, in Satoshis. required: true in: "formData"
};

/**
 * POST /api/v1/position/transferMargin
 * Transfer equity in or out of a position.
 */
struct PositionTransferIsolatedMarginParams {
    const char *  symbol;                    ///< Symbol of position to isolate. required: true in: "formData"
    long          amount;                    ///< Amount to transfer, in Satoshis. May be negative. required: true in: "formData"
};

/**
 * POST /api/v1/position/leverage
 * Choose leverage for a position.
 */
struct PositionUpdateLeverageParams {
    const char *  symbol;                    ///< Symbol of position to adjust. required: true in: "formData"
    double        leverage;                  ///< Leverage value. Send a number between 0.01 and 100 to enable isolated margin with a fixed leverage. Send 0 to enable cross margin. required: true in: "formData"
};

/**
 * GET /api/v1/quote
 * Get Quotes.
 * security: []
 */
struct QuoteGetParams {
    const char *  symbol;                    ///< Instrument symbol. Send a bare series (e.g. XBU) to get data for the nearest expiring contract in that series.  You can also send a timeframe, e.g. `XBU:monthly`. Timeframes are `daily`, `weekly`, `monthly`, `quarterly`, and `biquarterly`. required: false in: "query"
    json_t        filter;                    ///< Generic table filter. Send JSON key/value pairs, such as `{"key": "value"}`. You can key on individual fields, and do more advanced querying on timestamps. See the [Timestamp Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for more details. required: false in: "query"
    json_t        columns;                   ///< Array of column names to fetch. If omitted, will return all columns.  Note that this method will always return item keys, even when not specified, so you may receive more columns that you expect. required: false in: "query"
    long          count;                     ///< Number of results to fetch. default: 100 required: false in: "query"
    long          start;                     ///< Starting point for results. default: 0 required: false in: "query"
    bool          reverse;                   ///< If true, will sort results newest first. default: false required: false in: "query"
    time_t        startTime;                 ///< Starting date filter for results. required: false in: "query"
    time_t        endTime;                   ///< Ending date filter for results. required: false in: "query"
};

/**
 * GET /api/v1/quote/bucketed
 * Get previous quotes in time buckets.
 * security: []
 */
struct QuoteGetBucketedParams {
    const char *  binSize;                   ///< Time interval to bucket by. Available options: [1m,5m,1h,1d]. default: "1m" required: false in: "query"
    bool          partial;                   ///< If true, will send in-progress (incomplete) bins for the current time period. default: false required: false in: "query"
    const char *  symbol;                    ///< Instrument symbol. Send a bare series (e.g. XBU) to get data for the nearest expiring contract in that series.  You can also send a timeframe, e.g. `XBU:monthly`. Timeframes are `daily`, `weekly`, `monthly`, `quarterly`, and `biquarterly`. required: false in: "query"
    json_t        filter;                    ///< Generic table filter. Send JSON key/value pairs, such as `{"key": "value"}`. You can key on individual fields, and do more advanced querying on timestamps. See the [Timestamp Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for more details. required: false in: "query"
    json_t        columns;                   ///< Array of column names to fetch. If omitted, will return all columns.  Note that this method will always return item keys, even when not specified, so you may receive more columns that you expect. required: false in: "query"
    long          count;                     ///< Number of results to fetch. default: 100 required: false in: "query"
    long          start;                     ///< Starting point for results. default: 0 required: false in: "query"
    bool          reverse;                   ///< If true, will sort results newest first. default: false required: false in: "query"
    time_t        startTime;                 ///< Starting date filter for results. required: false in: "query"
    time_t        endTime;                   ///< Ending date filter for results. required: false in: "query"
};

/**
 * GET /api/v1/schema
 * Get model schemata for data objects returned by this API.
 * security: []
 */
struct SchemaGetParams {
    const char *  model;                     ///< Optional model filter. If omitted, will return all models. required: false in: "query"
};

/**
 * GET /api/v1/schema/websocketHelp
 * Returns help text & subject list for websocket usage.
 * security: []
 */


/**
 * GET /api/v1/settlement
 * Get settlement history.
 * security: []
 */
struct SettlementGetParams {
    const char *  symbol;                    ///< Instrument symbol. Send a bare series (e.g. XBU) to get data for the nearest expiring contract in that series.  You can also send a timeframe, e.g. `XBU:monthly`. Timeframes are `daily`, `weekly`, `monthly`, `quarterly`, and `biquarterly`. required: false in: "query"
    json_t        filter;                    ///< Generic table filter. Send JSON key/value pairs, such as `{"key": "value"}`. You can key on individual fields, and do more advanced querying on timestamps. See the [Timestamp Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for more details. required: false in: "query"
    json_t        columns;                   ///< Array of column names to fetch. If omitted, will return all columns.  Note that this method will always return item keys, even when not specified, so you may receive more columns that you expect. required: false in: "query"
    long          count;                     ///< Number of results to fetch. default: 100 required: false in: "query"
    long          start;                     ///< Starting point for results. default: 0 required: false in: "query"
    bool          reverse;                   ///< If true, will sort results newest first. default: false required: false in: "query"
    time_t        startTime;                 ///< Starting date filter for results. required: false in: "query"
    time_t        endTime;                   ///< Ending date filter for results. required: false in: "query"
};

/**
 * GET /api/v1/stats
 * Get exchange-wide and per-series turnover and volume statistics.
 * security: []
 */


/**
 * GET /api/v1/stats/history
 * Get historical exchange-wide and per-series turnover and volume statistics.
 * security: []
 */


/**
 * GET /api/v1/stats/historyUSD
 * Get a summary of exchange statistics in USD.
 * security: []
 */


/**
 * GET /api/v1/trade
 * Get Trades.
 * security: []
 */
struct TradeGetParams {
    const char *  symbol;                    ///< Instrument symbol. Send a bare series (e.g. XBU) to get data for the nearest expiring contract in that series.  You can also send a timeframe, e.g. `XBU:monthly`. Timeframes are `daily`, `weekly`, `monthly`, `quarterly`, and `biquarterly`. required: false in: "query"
    json_t        filter;                    ///< Generic table filter. Send JSON key/value pairs, such as `{"key": "value"}`. You can key on individual fields, and do more advanced querying on timestamps. See the [Timestamp Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for more details. required: false in: "query"
    json_t        columns;                   ///< Array of column names to fetch. If omitted, will return all columns.  Note that this method will always return item keys, even when not specified, so you may receive more columns that you expect. required: false in: "query"
    long          count;                     ///< Number of results to fetch. default: 100 required: false in: "query"
    long          start;                     ///< Starting point for results. default: 0 required: false in: "query"
    bool          reverse;                   ///< If true, will sort results newest first. default: false required: false in: "query"
    time_t        startTime;                 ///< Starting date filter for results. required: false in: "query"
    time_t        endTime;                   ///< Ending date filter for results. required: false in: "query"
};

/**
 * GET /api/v1/trade/bucketed
 * Get previous trades in time buckets.
 * security: []
 */
struct TradeGetBucketedParams {
    const char *  binSize;                   ///< Time interval to bucket by. Available options: [1m,5m,1h,1d]. default: "1m" required: false in: "query"
    bool          partial;                   ///< If true, will send in-progress (incomplete) bins for the current time period. default: false required: false in: "query"
    const char *  symbol;                    ///< Instrument symbol. Send a bare series (e.g. XBU) to get data for the nearest expiring contract in that series.  You can also send a timeframe, e.g. `XBU:monthly`. Timeframes are `daily`, `weekly`, `monthly`, `quarterly`, and `biquarterly`. required: false in: "query"
    json_t        filter;                    ///< Generic table filter. Send JSON key/value pairs, such as `{"key": "value"}`. You can key on individual fields, and do more advanced querying on timestamps. See the [Timestamp Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for more details. required: false in: "query"
    json_t        columns;                   ///< Array of column names to fetch. If omitted, will return all columns.  Note that this method will always return item keys, even when not specified, so you may receive more columns that you expect. required: false in: "query"
    long          count;                     ///< Number of results to fetch. default: 100 required: false in: "query"
    long          start;                     ///< Starting point for results. default: 0 required: false in: "query"
    bool          reverse;                   ///< If true, will sort results newest first. default: false required: false in: "query"
    time_t        startTime;                 ///< Starting date filter for results. required: false in: "query"
    time_t        endTime;                   ///< Ending date filter for results. required: false in: "query"
};

/**
 * GET /api/v1/user/depositAddress
 * Get a deposit address.
 */
struct UserGetDepositAddressParams {
    const char *  currency;                  ///<  default: "XBt" required: false in: "query"
};

/**
 * GET /api/v1/user/wallet
 * Get your current wallet information.
 */
struct UserGetWalletParams {
    const char *  currency;                  ///<  default: "XBt" required: false in: "query"
};

/**
 * GET /api/v1/user/walletHistory
 * Get a history of all of your wallet transactions (deposits, withdrawals, PNL).
 */
struct UserGetWalletHistoryParams {
    const char *  currency;                  ///<  default: "XBt" required: false in: "query"
};

/**
 * GET /api/v1/user/walletSummary
 * Get a summary of all of your wallet transactions (deposits, withdrawals, PNL).
 */
struct UserGetWalletSummaryParams {
    const char *  currency;                  ///<  default: "XBt" required: false in: "query"
};

/**
 * GET /api/v1/user/minWithdrawalFee
 * Get the minimum withdrawal fee for a currency.
 * security: []
 */
struct UserMinWithdrawalFeeParams {
    const char *  currency;                  ///<  default: "XBt" required: false in: "query"
};

/**
 * POST /api/v1/user/requestWithdrawal
 * Request a withdrawal to an external wallet.
 */
struct UserRequestWithdrawalParams {
    const char *  otpToken;                  ///< 2FA token. Required if 2FA is enabled on your account. required: false in: "formData"
    const char *  currency;                  ///< Currency you're withdrawing. Options: `XBt` default: "XBt" required: true in: "formData"
    long          amount;                    ///< Amount of withdrawal currency. required: true in: "formData"
    const char *  address;                   ///< Destination Address. required: true in: "formData"
    double        fee;                       ///< Network fee for Bitcoin withdrawals. If not specified, a default value will be calculated based on Bitcoin network conditions. You will have a chance to confirm this via email. required: false in: "formData"
};

/**
 * POST /api/v1/user/cancelWithdrawal
 * Cancel a withdrawal.
 * security: []
 */
struct UserCancelWithdrawalParams {
    const char *  token;                     ///<  required: true in: "formData"
};

/**
 * POST /api/v1/user/confirmWithdrawal
 * Confirm a withdrawal.
 * security: []
 */
struct UserConfirmWithdrawalParams {
    const char *  token;                     ///<  required: true in: "formData"
};

/**
 * POST /api/v1/user/requestEnableTFA
 * Get secret key for setting up two-factor auth.
 */
struct UserRequestEnableTFAParams {
    const char *  type;                      ///< Two-factor auth type. Supported types: 'GA' (Google Authenticator) required: false in: "formData"
};

/**
 * POST /api/v1/user/confirmEnableTFA
 * Confirm two-factor auth for this account. If using a Yubikey, simply send a token to this endpoint.
 */
struct UserConfirmEnableTFAParams {
    const char *  type;                      ///< Two-factor auth type. Supported types: 'GA' (Google Authenticator), 'Yubikey' required: false in: "formData"
    const char *  token;                     ///< Token from your selected TFA type. required: true in: "formData"
};

/**
 * POST /api/v1/user/disableTFA
 * Disable two-factor auth for this account.
 */
struct UserDisableTFAParams {
    const char *  type;                      ///< Two-factor auth type. Supported types: 'GA' (Google Authenticator) required: false in: "formData"
    const char *  token;                     ///< Token from your selected TFA type. required: true in: "formData"
};

/**
 * POST /api/v1/user/confirmEmail
 * Confirm your email address with a token.
 * security: []
 */
struct UserConfirmParams {
    const char *  token;                     ///<  required: true in: "formData"
};

/**
 * GET /api/v1/user/affiliateStatus
 * Get your current affiliate/referral status.
 */


/**
 * GET /api/v1/user/checkReferralCode
 * Check if a referral code is valid.
 * security: []
 */
struct UserCheckReferralCodeParams {
    const char *  referralCode;              ///<  required: false in: "query"
};

/**
 * POST /api/v1/user/logout
 * Log out of BitMEX.
 * security: []
 */


/**
 * POST /api/v1/user/logoutAll
 * Log all systems out of BitMEX. This will revoke all of your account's access tokens, logging you out on all devices.
 */


/**
 * POST /api/v1/user/preferences
 * Save user preferences.
 */
struct UserSavePreferencesParams {
    json_t        prefs;                     ///<  required: true in: "formData"
    bool          overwrite;                 ///< If true, will overwrite all existing preferences. default: false required: false in: "formData"
};

/**
 * GET /api/v1/user
 * Get your user model.
 */


/**
 * GET /api/v1/user/commission
 * Get your account's commission status.
 */


/**
 * GET /api/v1/user/margin
 * Get your account's margin status. Send a currency of "all" to receive an array of all supported currencies.
 */
struct UserGetMarginParams {
    const char *  currency;                  ///<  default: "XBt" required: false in: "query"
};


#endif /* __BITMEXAPIDEF_H__ */
